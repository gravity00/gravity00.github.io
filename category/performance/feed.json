{
    "version": "https://jsonfeed.org/version/1",
    "title": "code-corner.dev • All posts by \"performance\" category",
    "description": "",
    "home_page_url": "https://code-corner.dev",
    "items": [
        {
            "id": "https://code-corner.dev/2024/06/19/NET-9-ToList-vs-ToArray/",
            "url": "https://code-corner.dev/2024/06/19/NET-9-ToList-vs-ToArray/",
            "title": ".NET 9 - ToList vs ToArray",
            "date_published": "2024-06-18T23:00:00.000Z",
            "content_html": "<p>Last year I made an <a href=\"/2023/11/09/NET-%E2%80%94-ToList-vs-ToArray/\" title=\".NET — ToList vs ToArray\">article comparing the performance of ToList versus ToArray</a> when creating short lived collections that won’t be mutated, usually used to prevent multiple enumerations when iterating over a temporary LINQ transformation or to ensure mapping exceptions will be thrown inside the corresponding application layer.</p>\n<p>The tests were performed with .NET Framework 4.8, .NET 7 and .NET 8, which concluded that <code>ToArray</code> is significantly faster and more memory efficient for almost all collection sizes, with the only exception with very large collections in .NET 8 were <code>ToList</code> was faster - but still uses more memory).</p>\n<p>Assuming everything goes as planed, <a href=\"https://devblogs.microsoft.com/dotnet/our-vision-for-dotnet-9/\">Microsoft should release .NET 9 by the end of 2024</a>. This is the next major version of their most popular development framework that will bring a lot of new features (C# 13 is one of them) and performance improvements.</p>\n<p>Since we already have .NET 9 preview 5 available, which contains an even more optimized <code>SegmentedArrayBuilder</code> that is used internally by <code>ToArray</code>, I think it is a good time to compare the performance of both these methods in .NET 9 while using .NET 8 as the baseline.</p>\n<h1 id=\"Performance-Test\"><a href=\"#Performance-Test\" class=\"headerlink\" title=\"Performance Test\"></a>Performance Test</h1><p>Once again, I’m going to use the well known C# library <code>BenchmarkDotNet</code> to run the tests and the environment will be the following:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BenchmarkDotNet v0.13.10, Windows 11 (10.0.22631.3737/23H2/2023Update/SunValley3)</span><br><span class=\"line\">AMD Ryzen 7 3700X, 1 CPU, 16 logical and 8 physical cores</span><br><span class=\"line\">.NET SDK 9.0.100-preview.5.24307.3</span><br><span class=\"line\">  [Host]               : .NET 8.0.6 (8.0.624.26715), X64 RyuJIT AVX2</span><br><span class=\"line\">  .NET 8.0             : .NET 8.0.6 (8.0.624.26715), X64 RyuJIT AVX2</span><br><span class=\"line\">  .NET 9.0             : .NET 9.0.0 (9.0.24.30607), X64 RyuJIT AVX2</span><br><span class=\"line\">  .NET Framework 4.8.1 : .NET Framework 4.8.1 (4.8.9241.0), X64 RyuJIT VectorSize=256</span><br></pre></td></tr></table></figure>\n\n<p>The test consists in the creation of a collection that will hold random integers with a size defined by a test parameter. To ensure the collection initialization doesn’t affect performance, it will be created and cached during test setup, but converted to a new <code>IEnumerable</code> before invoking either <code>ToArray</code> or <code>ToList</code>.</p>\n<p>Keep in mind we want to test the performance of iterating over an <code>IEnumerable</code> and create either an array or a list so, to prevent .NET internal optimizations (like using a <code>SelectArrayIterator</code>), the method that converts the cached array to an <code>IEnumerable</code> will use the <code>yield return</code> keyword. This is different than the <a href=\"/2023/11/09/NET-%E2%80%94-ToList-vs-ToArray/\" title=\".NET — ToList vs ToArray\">previous article</a> were I was using the <code>Select</code> method which would return an optimized enumerable for arrays and I want to test the worst case scenario.</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">SimpleJob(RuntimeMoniker.Net80, baseline: true)</span>]</span><br><span class=\"line\">[<span class=\"meta\">SimpleJob(RuntimeMoniker.Net90)</span>]</span><br><span class=\"line\">[<span class=\"meta\">MemoryDiagnoser</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">ToListVsToArray</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"meta\">Params(10, 100, 1000, 10000, 100000)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> Size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">int</span>[] _items;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">GlobalSetup</span>]</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Setup</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> random = <span class=\"keyword\">new</span> Random(<span class=\"number\">123</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        _items = Enumerable.Range(<span class=\"number\">0</span>, Size).Select(_ =&gt; random.Next()).ToArray();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Benchmark</span>]</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span>[] <span class=\"title\">ToArray</span>()</span> =&gt; CreateItemsEnumerable().ToArray();</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Benchmark</span>]</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;<span class=\"built_in\">int</span>&gt; <span class=\"title\">ToList</span>()</span> =&gt; CreateItemsEnumerable().ToList();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> IEnumerable&lt;<span class=\"built_in\">int</span>&gt; <span class=\"title\">CreateItemsEnumerable</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> item <span class=\"keyword\">in</span> _items)</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> <span class=\"keyword\">return</span> item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Performance-results\"><a href=\"#Performance-results\" class=\"headerlink\" title=\"Performance results\"></a>Performance results</h1><p>Since this article is a continuation of my <a href=\"/2023/11/09/NET-%E2%80%94-ToList-vs-ToArray/\" title=\".NET — ToList vs ToArray\">previous one</a>, were I concluded using <code>ToArray</code> is faster and more memory efficient than <code>ToList</code>, let’s compare if that statement still holds true.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| Method  | Size   | Mean          | Error         | StdDev        | Gen0     | Gen1     | Gen2     | Allocated |</span><br><span class=\"line\">|-------- |------- |--------------:|--------------:|--------------:|---------:|---------:|---------:|----------:|</span><br><span class=\"line\">| ToArray | 10     |      70.39 ns |      0.366 ns |      0.342 ns |   0.0134 |        - |        - |     112 B |</span><br><span class=\"line\">| ToList  | 10     |      72.85 ns |      0.744 ns |      0.696 ns |   0.0315 |        - |        - |     264 B |</span><br><span class=\"line\">| ToArray | 100    |     322.65 ns |      1.816 ns |      1.610 ns |   0.0563 |        - |        - |     472 B |</span><br><span class=\"line\">| ToList  | 100    |     368.11 ns |      4.283 ns |      4.006 ns |   0.1469 |        - |        - |    1232 B |</span><br><span class=\"line\">| ToArray | 1000   |   2,451.62 ns |     19.687 ns |     16.439 ns |   0.4845 |        - |        - |    4072 B |</span><br><span class=\"line\">| ToList  | 1000   |   2,854.28 ns |     24.286 ns |     22.717 ns |   1.0109 |   0.0153 |        - |    8472 B |</span><br><span class=\"line\">| ToArray | 10000  |  22,275.27 ns |    163.363 ns |    152.810 ns |   4.7607 |        - |        - |   40072 B |</span><br><span class=\"line\">| ToList  | 10000  |  26,944.65 ns |    293.685 ns |    260.344 ns |  15.6250 |        - |        - |  131448 B |</span><br><span class=\"line\">| ToArray | 100000 | 328,160.90 ns |  1,874.673 ns |  1,753.570 ns | 124.5117 | 124.5117 | 124.5117 |  400156 B |</span><br><span class=\"line\">| ToList  | 100000 | 410,583.73 ns |  2,298.854 ns |  2,037.874 ns | 285.6445 | 285.6445 | 285.6445 | 1049120 B |</span><br></pre></td></tr></table></figure>\n\n<p>Using <code>ToList</code> as the baseline, we can see the <code>ToArray</code> method is, on average, 15% faster and uses 60% less memory.</p>\n<p>Keep in mind that <code>ToArray</code> is a better choice than <code>ToList</code> even on larger collections, something that wasn’t true in .NET 8, were it was 4% slower despite using less memory.</p>\n<p><strong>The winner:</strong> .NET 9.0</p>\n<h1 id=\"NET-performance-evolution\"><a href=\"#NET-performance-evolution\" class=\"headerlink\" title=\".NET performance evolution\"></a>.NET performance evolution</h1><p>Because we also want to compare the performance of .NET 9 over .NET 8, let’s analyze each method individually on each framework and see if anything has changed.</p>\n<h2 id=\"ToArray\"><a href=\"#ToArray\" class=\"headerlink\" title=\"ToArray\"></a>ToArray</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| Runtime  | Size   | Mean          | Error         | StdDev        | Ratio | RatioSD | Gen0     | Gen1     | Gen2     | Allocated | Alloc Ratio |</span><br><span class=\"line\">|----------|------- |--------------:|--------------:|--------------:|------:|--------:|---------:|---------:|---------:|----------:|------------:|</span><br><span class=\"line\">| .NET 8.0 | 10     |     107.51 ns |      1.585 ns |      1.238 ns |  1.00 |    0.00 |   0.0315 |        - |        - |     264 B |        1.00 |</span><br><span class=\"line\">| .NET 9.0 | 10     |      70.39 ns |      0.366 ns |      0.342 ns |  0.65 |    0.01 |   0.0134 |        - |        - |     112 B |        0.42 |</span><br><span class=\"line\">| .NET 8.0 | 100    |     442.33 ns |      3.788 ns |      3.543 ns |  1.00 |    0.00 |   0.1431 |        - |        - |    1200 B |        1.00 |</span><br><span class=\"line\">| .NET 9.0 | 100    |     322.65 ns |      1.816 ns |      1.610 ns |  0.73 |    0.01 |   0.0563 |        - |        - |     472 B |        0.39 |</span><br><span class=\"line\">| .NET 8.0 | 1000   |   3,186.13 ns |     31.530 ns |     29.493 ns |  1.00 |    0.00 |   1.0185 |        - |        - |    8544 B |        1.00 |</span><br><span class=\"line\">| .NET 9.0 | 1000   |   2,451.62 ns |     19.687 ns |     16.439 ns |  0.77 |    0.00 |   0.4845 |        - |        - |    4072 B |        0.48 |</span><br><span class=\"line\">| .NET 8.0 | 10000  |  30,659.83 ns |    292.167 ns |    273.293 ns |  1.00 |    0.00 |  12.6343 |        - |        - |  106232 B |        1.00 |</span><br><span class=\"line\">| .NET 9.0 | 10000  |  22,275.27 ns |    163.363 ns |    152.810 ns |  0.73 |    0.00 |   4.7607 |        - |        - |   40072 B |        0.38 |</span><br><span class=\"line\">| .NET 8.0 | 100000 | 482,397.96 ns |  1,499.949 ns |  1,403.053 ns |  1.00 |    0.00 | 249.5117 | 249.5117 | 249.5117 |  925140 B |        1.00 |</span><br><span class=\"line\">| .NET 9.0 | 100000 | 328,160.90 ns |  1,874.673 ns |  1,753.570 ns |  0.68 |    0.00 | 124.5117 | 124.5117 | 124.5117 |  400156 B |        0.43 |</span><br></pre></td></tr></table></figure>\n\n<p>Using .NET 8 as the baseline, we can see the <code>ToArray</code> method is, on average, 30% faster and uses 55% less memory on .NET 9. </p>\n<p><strong>The winner:</strong> .NET 9.0</p>\n<h2 id=\"ToList\"><a href=\"#ToList\" class=\"headerlink\" title=\"ToList\"></a>ToList</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| Runtime  | Size   | Mean          | Error         | StdDev        | Ratio | RatioSD | Gen0     | Gen1     | Gen2     | Allocated | Alloc Ratio |</span><br><span class=\"line\">|----------|------- |--------------:|--------------:|--------------:|------:|--------:|---------:|---------:|---------:|----------:|------------:|</span><br><span class=\"line\">| .NET 8.0 | 10     |      87.44 ns |      1.803 ns |      1.929 ns |  1.00 |    0.00 |   0.0315 |        - |        - |     264 B |        1.00 |</span><br><span class=\"line\">| .NET 9.0 | 10     |      72.85 ns |      0.744 ns |      0.696 ns |  0.84 |    0.02 |   0.0315 |        - |        - |     264 B |        1.00 |</span><br><span class=\"line\">| .NET 8.0 | 100    |     420.90 ns |      3.654 ns |      2.853 ns |  1.00 |    0.00 |   0.1469 |        - |        - |    1232 B |        1.00 |</span><br><span class=\"line\">| .NET 9.0 | 100    |     368.11 ns |      4.283 ns |      4.006 ns |  0.87 |    0.01 |   0.1469 |        - |        - |    1232 B |        1.00 |</span><br><span class=\"line\">| .NET 8.0 | 1000   |   3,448.37 ns |     67.905 ns |     78.199 ns |  1.00 |    0.00 |   1.0109 |   0.0153 |        - |    8472 B |        1.00 |</span><br><span class=\"line\">| .NET 9.0 | 1000   |   2,854.28 ns |     24.286 ns |     22.717 ns |  0.82 |    0.01 |   1.0109 |   0.0153 |        - |    8472 B |        1.00 |</span><br><span class=\"line\">| .NET 8.0 | 10000  |  35,650.35 ns |    707.370 ns |  1,537.764 ns |  1.00 |    0.00 |  15.6250 |        - |        - |  131448 B |        1.00 |</span><br><span class=\"line\">| .NET 9.0 | 10000  |  26,944.65 ns |    293.685 ns |    260.344 ns |  0.77 |    0.05 |  15.6250 |        - |        - |  131448 B |        1.00 |</span><br><span class=\"line\">| .NET 8.0 | 100000 | 462,317.72 ns |  1,686.365 ns |  1,577.427 ns |  1.00 |    0.00 | 285.6445 | 285.6445 | 285.6445 | 1049120 B |        1.00 |</span><br><span class=\"line\">| .NET 9.0 | 100000 | 410,583.73 ns |  2,298.854 ns |  2,037.874 ns |  0.89 |    0.01 | 285.6445 | 285.6445 | 285.6445 | 1049120 B |        1.00 |</span><br></pre></td></tr></table></figure>\n\n<p>Using .NET 8 as the baseline, we can see the <code>ToList</code> method is, on average, 15% faster while having exactly the same memory footprint on .NET 9.</p>\n<p><strong>The winner:</strong> .NET 9.0</p>\n<h1 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h1><p>In this article we compared the performance of <code>ToArray</code> versus <code>ToList</code> on .NET 9 and concluded, once again, if you need to create a temporary collection in memory to prevent multiple enumerations of an <code>IEnumerable</code>, using <code>ToArray</code> is more performant in all scenarios independent of collection size, something that wasn’t true in .NET 8.</p>\n<p>This is also a clear statement that Microsoft made a good decision to introduce classes and structures dedicated to performance, like <code>ArrayPool</code> or <code>ReadOnlySpan</code>, making it easier to share or reuse resources without constantly (de)allocating memory. This has been specially important for our performance tests since <code>SegmentedArrayBuilder</code> makes heavy use of these functionalities, now more than ever.</p>\n",
            "tags": [
                "dotnetcore",
                "csharp",
                "dotnet",
                "linq"
            ]
        },
        {
            "id": "https://code-corner.dev/2024/04/14/NET-9-%E2%80%94-Exception-handling-performance/",
            "url": "https://code-corner.dev/2024/04/14/NET-9-%E2%80%94-Exception-handling-performance/",
            "title": ".NET 9 — Exception handling performance",
            "date_published": "2024-04-13T23:00:00.000Z",
            "content_html": "<p>Assuming everything goes as planed, <a href=\"https://devblogs.microsoft.com/dotnet/our-vision-for-dotnet-9/\">by the end of 2024 Microsoft should release .NET 9</a>, which is the next major version of their most popular development framework.</p>\n<p>It will bring a lot of new features (C# 13 is one of them) but also a lot of performance improvements, which have been a major focus ever since Microsoft created the first version of .NET Core.</p>\n<p>Even if an application doesn’t rely on exceptions to hard stop process flows, usually very important for high demanding applications, it certainly connects to a lot of external systems, like databases, message buses, caches and even HTTP endpoints, which may cause exceptions at any moment.</p>\n<p>In this article I’m going to test how exception handling performance improved over the years by comparing how faster is .NET 9 over .NET 8.</p>\n<p>I’m going to use the well known C# library <code>BenchmarkDotNet</code> to run the tests and the environment will be the following:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BenchmarkDotNet v0.13.12, Windows 11 (10.0.22631.3447/23H2/2023Update/SunValley3)</span><br><span class=\"line\">AMD Ryzen 7 3700X, 1 CPU, 16 logical and 8 physical cores</span><br><span class=\"line\">.NET SDK 9.0.100-preview.3.24204.13</span><br><span class=\"line\">  [Host]               : .NET 8.0.4 (8.0.424.16909), X64 RyuJIT AVX2</span><br><span class=\"line\">  .NET 8.0             : .NET 8.0.4 (8.0.424.16909), X64 RyuJIT AVX2</span><br><span class=\"line\">  .NET 9.0             : .NET 9.0.0 (9.0.24.17209), X64 RyuJIT AVX2</span><br><span class=\"line\">  .NET Framework 4.8.1 : .NET Framework 4.8.1 (4.8.9232.0), X64 RyuJIT VectorSize=256</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"Performance-test\"><a href=\"#Performance-test\" class=\"headerlink\" title=\"Performance test\"></a>Performance test</h1><p>To test the performance of exception handling I’m going to define two simple scenarios:</p>\n<ol>\n<li><strong>Ignore exception</strong> — the simplest possible scenario to measure the performance of throwing and catching an exception;</li>\n<li><strong>Convert to string</strong> — the most common scenario when working with logging frameworks which usually use the ToString method to get a text representation containing both the message and stack trace;</li>\n</ol>\n<p>Because asynchronous code with <code>async/await</code> has become very common and it directly affects the complexity of stack trace information, I’m also going to test both scenarios asynchronously.</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">SimpleJob(RuntimeMoniker.Net481)</span>]</span><br><span class=\"line\">[<span class=\"meta\">SimpleJob(RuntimeMoniker.Net80, baseline: true)</span>]</span><br><span class=\"line\">[<span class=\"meta\">SimpleJob(RuntimeMoniker.Net90)</span>]</span><br><span class=\"line\">[<span class=\"meta\">MemoryDiagnoser</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">ThrowExceptionPerfTest</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"meta\">Benchmark</span>]</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Catch_Ignore</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ThrowException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Benchmark</span>]</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">string</span> <span class=\"title\">Catch_ToString</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ThrowException();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (Exception e)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e.ToString();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">ThrowException</span>()</span> =&gt; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">&quot;test exception&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Benchmark</span>]</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">async</span> ValueTask <span class=\"title\">Catch_Ignore_Async</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">await</span> ThrowExceptionAsync();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Benchmark</span>]</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">async</span> ValueTask&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">Catch_ToString_Async</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">await</span> ThrowExceptionAsync();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (Exception e)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e.ToString();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> ValueTask <span class=\"title\">ThrowExceptionAsync</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">await</span> Task.Yield();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">&quot;test exception&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Performance-results\"><a href=\"#Performance-results\" class=\"headerlink\" title=\"Performance results\"></a>Performance results</h1><p>I’m going to use .NET 8 as the baseline since it is the most recent and performant version currently available, but I’m also including .NET Framework 4.8.1 so we can also compare how .NET in general have improved over the years.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| Method               | Runtime              | Mean      | Error     | StdDev    | Ratio | RatioSD | Gen0   | Gen1   | Allocated | Alloc Ratio |</span><br><span class=\"line\">|--------------------- |--------------------- |----------:|----------:|----------:|------:|--------:|-------:|-------:|----------:|------------:|</span><br><span class=\"line\">| Catch_Ignore         | .NET 8.0             |  6.130 us | 0.0738 us | 0.0654 us |  1.00 |    0.00 | 0.0381 |      - |     344 B |        1.00 |</span><br><span class=\"line\">| Catch_Ignore         | .NET 9.0             |  3.059 us | 0.0219 us | 0.0183 us |  0.50 |    0.01 | 0.0381 |      - |     344 B |        1.00 |</span><br><span class=\"line\">| Catch_Ignore         | .NET Framework 4.8.1 |  7.178 us | 0.0358 us | 0.0299 us |  1.17 |    0.01 | 0.0687 |      - |     433 B |        1.26 |</span><br><span class=\"line\">|                      |                      |           |           |           |       |         |        |        |           |             |</span><br><span class=\"line\">| Catch_ToString       | .NET 8.0             | 11.472 us | 0.0854 us | 0.0798 us |  1.00 |    0.00 | 0.6409 |      - |    5384 B |        1.00 |</span><br><span class=\"line\">| Catch_ToString       | .NET 9.0             |  7.849 us | 0.1512 us | 0.1263 us |  0.68 |    0.01 | 0.6409 |      - |    5384 B |        1.00 |</span><br><span class=\"line\">| Catch_ToString       | .NET Framework 4.8.1 | 14.393 us | 0.1046 us | 0.0874 us |  1.25 |    0.01 | 1.0376 |      - |    6604 B |        1.23 |</span><br><span class=\"line\">|                      |                      |           |           |           |       |         |        |        |           |             |</span><br><span class=\"line\">| Catch_Ignore_Async   | .NET 8.0             | 21.662 us | 0.4302 us | 1.0056 us |  1.00 |    0.00 | 0.1221 |      - |    1248 B |        1.00 |</span><br><span class=\"line\">| Catch_Ignore_Async   | .NET 9.0             | 11.690 us | 0.1647 us | 0.1375 us |  0.54 |    0.03 | 0.1373 |      - |    1243 B |        1.00 |</span><br><span class=\"line\">| Catch_Ignore_Async   | .NET Framework 4.8.1 | 23.139 us | 0.0875 us | 0.0775 us |  1.06 |    0.06 | 0.2441 |      - |    1663 B |        1.33 |</span><br><span class=\"line\">|                      |                      |           |           |           |       |         |        |        |           |             |</span><br><span class=\"line\">| Catch_ToString_Async | .NET 8.0             | 44.680 us | 0.7175 us | 0.5991 us |  1.00 |    0.00 | 1.0986 |      - |   10025 B |        1.00 |</span><br><span class=\"line\">| Catch_ToString_Async | .NET 9.0             | 36.583 us | 0.7125 us | 0.7623 us |  0.82 |    0.02 | 1.0986 |      - |   10105 B |        1.01 |</span><br><span class=\"line\">| Catch_ToString_Async | .NET Framework 4.8.1 | 45.369 us | 0.7617 us | 1.0924 us |  1.01 |    0.02 | 1.8921 | 0.0610 |   11999 B |        1.20 |</span><br></pre></td></tr></table></figure>\n\n<p>Let’s analyze each result individualy.</p>\n<h2 id=\"Catch-and-ignore\"><a href=\"#Catch-and-ignore\" class=\"headerlink\" title=\"Catch and ignore\"></a>Catch and ignore</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| Runtime              | Mean      | Error     | StdDev    | Ratio | RatioSD |</span><br><span class=\"line\">|--------------------- |----------:|----------:|----------:|------:|--------:|</span><br><span class=\"line\">| .NET 8.0             |  6.130 us | 0.0738 us | 0.0654 us |  1.00 |    0.00 |</span><br><span class=\"line\">| .NET 9.0             |  3.059 us | 0.0219 us | 0.0183 us |  0.50 |    0.01 |</span><br><span class=\"line\">| .NET Framework 4.8.1 |  7.178 us | 0.0358 us | 0.0299 us |  1.17 |    0.01 |</span><br></pre></td></tr></table></figure>\n\n<p>The simplest scenario shows .NET 9 with a 50% performance improvement over .NET 8, which was already 15% faster that .NET Framework 4.8.1.</p>\n<p><strong>Who’s the winner?</strong> .NET 9</p>\n<h2 id=\"Catch-and-convert-to-string\"><a href=\"#Catch-and-convert-to-string\" class=\"headerlink\" title=\"Catch and convert to string\"></a>Catch and convert to string</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| Runtime              | Mean      | Error     | StdDev    | Ratio | RatioSD |</span><br><span class=\"line\">|--------------------- |----------:|----------:|----------:|------:|--------:|</span><br><span class=\"line\">| .NET 8.0             | 11.472 us | 0.0854 us | 0.0798 us |  1.00 |    0.00 |</span><br><span class=\"line\">| .NET 9.0             |  7.849 us | 0.1512 us | 0.1263 us |  0.68 |    0.01 |</span><br><span class=\"line\">| .NET Framework 4.8.1 | 14.393 us | 0.1046 us | 0.0874 us |  1.25 |    0.01 |</span><br></pre></td></tr></table></figure>\n\n<p>In this scenario, using the <code>ToString</code> method is 32% faster in .NET 9 than .NET 8, and about 45% faster than .NET Framework 4.8.1.</p>\n<p><strong>Who’s the winner?</strong> .NET 9</p>\n<h2 id=\"Catch-and-ignore-async\"><a href=\"#Catch-and-ignore-async\" class=\"headerlink\" title=\"Catch and ignore (async)\"></a>Catch and ignore (async)</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| Runtime              | Mean      | Error     | StdDev    | Ratio | RatioSD |</span><br><span class=\"line\">|--------------------- |----------:|----------:|----------:|------:|--------:|</span><br><span class=\"line\">| .NET 8.0             | 21.662 us | 0.4302 us | 1.0056 us |  1.00 |    0.00 |</span><br><span class=\"line\">| .NET 9.0             | 11.690 us | 0.1647 us | 0.1375 us |  0.54 |    0.03 |</span><br><span class=\"line\">| .NET Framework 4.8.1 | 23.139 us | 0.0875 us | 0.0775 us |  1.06 |    0.06 |</span><br></pre></td></tr></table></figure>\n\n<p>In the simplest scenario, but with an asynchronous implementation, .NET 9 is 46% faster than .NET 8 and 50% faster than .NET Framework 4.8.1.</p>\n<p><strong>Who’s the winner?</strong> .NET 9</p>\n<h2 id=\"Catch-and-convert-to-string-async\"><a href=\"#Catch-and-convert-to-string-async\" class=\"headerlink\" title=\"Catch and convert to string (async)\"></a>Catch and convert to string (async)</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| Runtime              | Mean      | Error     | StdDev    | Ratio | RatioSD |</span><br><span class=\"line\">|--------------------- |----------:|----------:|----------:|------:|--------:|</span><br><span class=\"line\">| .NET 8.0             | 44.680 us | 0.7175 us | 0.5991 us |  1.00 |    0.00 |</span><br><span class=\"line\">| .NET 9.0             | 36.583 us | 0.7125 us | 0.7623 us |  0.82 |    0.02 |</span><br><span class=\"line\">| .NET Framework 4.8.1 | 45.369 us | 0.7617 us | 1.0924 us |  1.01 |    0.02 |</span><br></pre></td></tr></table></figure>\n\n<p>The catch and use the <code>ToString</code> method asynchronous implementation is 18% faster in .NET 9 than .NET 8 and 20% faster than .NET framework 4.8.1.</p>\n<p><strong>Who’s the winner?</strong> .NET 9</p>\n<h1 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h1><p>In this article we compared .NET 9, .NET 8 and .NET Framework 4.8.1 performance when throwing and handling exceptions, for both synchronous and asynchronous code, and concluded the future .NET release will come with significant improvements.</p>\n<p>This will certainly be important for high demanding systems that usually integrate with a lot of external systems, like message queues, databases or HTTP endpoints. Even in less complex scenarios it is good to know a simple change from .NET 8 or older versions to .NET 9 will increase the overall performance.</p>\n<p>Microsoft has been stepping in the right direction ever since they released .NET Core, and let’s hope they keep going.</p>\n",
            "tags": [
                "dotnetcore",
                "dotnet"
            ]
        },
        {
            "id": "https://code-corner.dev/2024/02/05/NET-%E2%80%94-LinkedList-vs-ToArray/",
            "url": "https://code-corner.dev/2024/02/05/NET-%E2%80%94-LinkedList-vs-ToArray/",
            "title": ".NET — LinkedList vs ToArray",
            "date_published": "2024-02-05T00:00:00.000Z",
            "content_html": "<p>Some weeks ago I created an <a href=\"/2023/11/09/NET-%E2%80%94-ToList-vs-ToArray/\" title=\".NET — ToList vs ToArray\">article comparing the performance of ToList versus ToArray</a> when creating short lived collections that won’t be mutated, usually used to prevent multiple enumerations when iterating over a temporary LINQ transformation or to ensure mapping exceptions will be thrown inside the corresponding application layer.</p>\n<p>In that article I concluded <code>ToArray</code> is faster and more memory efficient than <code>ToList</code> for almost any collection sizes and in any .NET version — tests were conducted on .NET Framework 4.8, .NET 7 and .NET 8.</p>\n<p><strong>But then I began to wonder:</strong> <em>If I’m creating a temporary collection of unknown size just to force enumeration, wouldn’t <code>LinkedList</code> be a more efficient collection since I’m only appending items to the end, which is O(1), instead of constantly allocating new arrays like <code>ToArray</code> does?</em></p>\n<p>I believe that’s a valid point so I decided to do a performance comparison between the two, assuming <code>ToArray</code> as the baseline and try to give a detailed explanation for the observed results.</p>\n<h1 id=\"Performance-test\"><a href=\"#Performance-test\" class=\"headerlink\" title=\"Performance test\"></a>Performance test</h1><p>The test consists in the creation of a collection that holds random integers, being the size defined by a parameter. To ensure the randomness does not affect the results, the values are cached into an array and, before invoking either <code>ToArray</code> or creating the <code>LinkedList</code>, they are converted into a new <code>IEnumerable</code>, not just a cast that could lead to internal optimizations.</p>\n<p>This time I decided to do the performance comparison only on .NET Framework 4.8 and .NET 8.</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">SimpleJob(RuntimeMoniker.Net48)</span>]</span><br><span class=\"line\">[<span class=\"meta\">SimpleJob(RuntimeMoniker.Net80)</span>]</span><br><span class=\"line\">[<span class=\"meta\">MemoryDiagnoser</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">LinkedListVsToArray</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"meta\">Params(10, 100, 1000, 10000, 100000)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> Size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">int</span>[] _items;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">GlobalSetup</span>]</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Setup</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> random = <span class=\"keyword\">new</span> Random(<span class=\"number\">123</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        _items = Enumerable.Range(<span class=\"number\">0</span>, Size).Select(_ =&gt; random.Next()).ToArray();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Benchmark(Baseline = true)</span>]</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span>[] <span class=\"title\">ToArray</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> items = CreateItemsEnumerable();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> items.ToArray();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Benchmark</span>]</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LinkedList&lt;<span class=\"built_in\">int</span>&gt; <span class=\"title\">ToLinkedList</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> items = CreateItemsEnumerable();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LinkedList&lt;<span class=\"built_in\">int</span>&gt;(items);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> IEnumerable&lt;<span class=\"built_in\">int</span>&gt; <span class=\"title\">CreateItemsEnumerable</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> item <span class=\"keyword\">in</span> _items)</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> <span class=\"keyword\">return</span> item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Performance-results\"><a href=\"#Performance-results\" class=\"headerlink\" title=\"Performance results\"></a>Performance results</h1><p>Because we want to decide, for a given application, between <code>ToArray</code> or <code>LinkedList</code> based on performance, let’s analyze the results for each framework version.</p>\n<h2 id=\"NET-Framework-4-8\"><a href=\"#NET-Framework-4-8\" class=\"headerlink\" title=\".NET Framework 4.8\"></a>.NET Framework 4.8</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| Method       | Size   | Mean           | Error        | StdDev       | Median         | Ratio | RatioSD | Gen0     | Gen1     | Gen2     | Allocated | Alloc Ratio |</span><br><span class=\"line\">|------------- |------- |---------------:|-------------:|-------------:|---------------:|------:|--------:|---------:|---------:|---------:|----------:|------------:|</span><br><span class=\"line\">| ToArray      | 10     |       143.4 ns |      2.82 ns |      2.64 ns |       143.5 ns |  1.00 |    0.00 |   0.0470 |        - |        - |     297 B |        1.00 |</span><br><span class=\"line\">| ToLinkedList | 10     |       175.4 ns |      1.57 ns |      1.39 ns |       175.6 ns |  1.23 |    0.02 |   0.0918 |        - |        - |     578 B |        1.95 |</span><br><span class=\"line\">| ToArray      | 100    |       891.6 ns |     17.68 ns |     27.00 ns |       883.8 ns |  1.00 |    0.00 |   0.2584 |        - |        - |    1629 B |        1.00 |</span><br><span class=\"line\">| ToLinkedList | 100    |     1,464.8 ns |     14.96 ns |     13.26 ns |     1,467.8 ns |  1.63 |    0.04 |   0.7801 |   0.0134 |        - |    4910 B |        3.01 |</span><br><span class=\"line\">| ToArray      | 1000   |     7,867.5 ns |    156.18 ns |    223.99 ns |     7,896.2 ns |  1.00 |    0.00 |   1.9836 |   0.0153 |        - |   12504 B |        1.00 |</span><br><span class=\"line\">| ToLinkedList | 1000   |    14,881.8 ns |    283.19 ns |    290.82 ns |    14,892.3 ns |  1.92 |    0.06 |   7.6599 |   1.0834 |        - |   48238 B |        3.86 |</span><br><span class=\"line\">| ToArray      | 10000  |    78,138.5 ns |  1,547.95 ns |  2,363.88 ns |    78,993.1 ns |  1.00 |    0.00 |  26.9775 |   5.3711 |        - |  171755 B |        1.00 |</span><br><span class=\"line\">| ToLinkedList | 10000  |   158,728.7 ns |  2,151.48 ns |  1,907.23 ns |   158,243.9 ns |  2.03 |    0.07 |  76.4160 |  12.4512 |        - |  481511 B |        2.80 |</span><br><span class=\"line\">| ToArray      | 100000 |   805,445.4 ns |  9,463.82 ns |  8,852.47 ns |   804,730.5 ns |  1.00 |    0.00 | 399.4141 | 399.4141 | 399.4141 | 1452144 B |        1.00 |</span><br><span class=\"line\">| ToLinkedList | 100000 | 3,632,195.6 ns | 49,765.42 ns | 46,550.60 ns | 3,633,088.3 ns |  4.51 |    0.08 | 757.8125 | 375.0000 |        - | 4814292 B |        3.32 |</span><br></pre></td></tr></table></figure>\n\n<p>The <code>ToArray</code> method is significantly faster and more memory efficient than creating a new <code>LinkedList</code>. Still, it does allocate more Gen2 memory for larger collections which may be something to consider.</p>\n<h2 id=\"NET-8\"><a href=\"#NET-8\" class=\"headerlink\" title=\".NET 8\"></a>.NET 8</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| Method       | Size   | Mean           | Error        | StdDev       | Median         | Ratio | RatioSD | Gen0     | Gen1     | Gen2     | Allocated | Alloc Ratio |</span><br><span class=\"line\">|------------- |------- |---------------:|-------------:|-------------:|---------------:|------:|--------:|---------:|---------:|---------:|----------:|------------:|</span><br><span class=\"line\">| ToArray      | 10     |       108.8 ns |      2.14 ns |      2.99 ns |       109.0 ns |  1.00 |    0.00 |   0.0315 |        - |        - |     264 B |        1.00 |</span><br><span class=\"line\">| ToLinkedList | 10     |       125.7 ns |      2.57 ns |      7.25 ns |       125.9 ns |  1.13 |    0.06 |   0.0677 |        - |        - |     568 B |        2.15 |</span><br><span class=\"line\">| ToArray      | 100    |       433.3 ns |      7.93 ns |      7.03 ns |       434.0 ns |  1.00 |    0.00 |   0.1431 |        - |        - |    1200 B |        1.00 |</span><br><span class=\"line\">| ToLinkedList | 100    |       979.2 ns |     19.54 ns |     40.79 ns |       977.9 ns |  2.34 |    0.09 |   0.5836 |   0.0095 |        - |    4888 B |        4.07 |</span><br><span class=\"line\">| ToArray      | 1000   |     3,100.4 ns |     34.14 ns |     28.51 ns |     3,090.9 ns |  1.00 |    0.00 |   1.0185 |        - |        - |    8544 B |        1.00 |</span><br><span class=\"line\">| ToLinkedList | 1000   |     9,135.9 ns |    179.58 ns |    345.98 ns |     9,205.1 ns |  3.03 |    0.08 |   5.7373 |   0.8850 |        - |   48088 B |        5.63 |</span><br><span class=\"line\">| ToArray      | 10000  |    31,587.6 ns |    604.95 ns |  1,437.72 ns |    31,129.4 ns |  1.00 |    0.00 |  12.6343 |        - |        - |  106232 B |        1.00 |</span><br><span class=\"line\">| ToLinkedList | 10000  |   109,454.7 ns |  2,152.65 ns |  4,198.57 ns |   107,653.8 ns |  3.43 |    0.11 |  57.3730 |  32.9590 |        - |  480088 B |        4.52 |</span><br><span class=\"line\">| ToArray      | 100000 |   531,028.2 ns |  3,515.73 ns |  3,288.62 ns |   531,061.8 ns |  1.00 |    0.00 | 249.0234 | 249.0234 | 249.0234 |  925140 B |        1.00 |</span><br><span class=\"line\">| ToLinkedList | 100000 | 2,295,939.2 ns | 44,598.15 ns | 62,520.38 ns | 2,288,468.0 ns |  4.33 |    0.13 | 570.3125 | 535.1563 |        - | 4800090 B |        5.19 |</span><br></pre></td></tr></table></figure>\n\n<p>Same behavior as .NET Framework 4.8, being the <code>ToArray</code> method much faster and memory efficient while still allocating more Gen2 memory on larger collections.</p>\n<h1 id=\"NET-performance-evolution\"><a href=\"#NET-performance-evolution\" class=\"headerlink\" title=\".NET performance evolution\"></a>.NET performance evolution</h1><p>Since in my previous article I already covered the <a href=\"/2023/11/09/NET-%E2%80%94-ToList-vs-ToArray/\" title=\".NET — ToList vs ToArray\">performance evolution of ToArray over the years</a>, let’s just compare how initializing a <code>LinkedList</code> from an <code>IEnumerable</code> have changed for different frameworks.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| Runtime            | Size   | Mean           | Error        | StdDev       | Median         | RatioSD | Gen0     | Gen1     | Gen2     | Allocated |</span><br><span class=\"line\">|------------------- |------- |---------------:|-------------:|-------------:|---------------:|--------:|---------:|---------:|---------:|----------:|</span><br><span class=\"line\">| .NET 8.0           | 10     |       125.7 ns |      2.57 ns |      7.25 ns |       125.9 ns |    0.06 |   0.0677 |        - |        - |     568 B |</span><br><span class=\"line\">| .NET Framework 4.8 | 10     |       175.4 ns |      1.57 ns |      1.39 ns |       175.6 ns |    0.02 |   0.0918 |        - |        - |     578 B |</span><br><span class=\"line\">| .NET 8.0           | 100    |       979.2 ns |     19.54 ns |     40.79 ns |       977.9 ns |    0.09 |   0.5836 |   0.0095 |        - |    4888 B |</span><br><span class=\"line\">| .NET Framework 4.8 | 100    |     1,464.8 ns |     14.96 ns |     13.26 ns |     1,467.8 ns |    0.04 |   0.7801 |   0.0134 |        - |    4910 B |</span><br><span class=\"line\">| .NET 8.0           | 1000   |     9,135.9 ns |    179.58 ns |    345.98 ns |     9,205.1 ns |    0.08 |   5.7373 |   0.8850 |        - |   48088 B |</span><br><span class=\"line\">| .NET Framework 4.8 | 1000   |    14,881.8 ns |    283.19 ns |    290.82 ns |    14,892.3 ns |    0.06 |   7.6599 |   1.0834 |        - |   48238 B |</span><br><span class=\"line\">| .NET 8.0           | 10000  |   109,454.7 ns |  2,152.65 ns |  4,198.57 ns |   107,653.8 ns |    0.11 |  57.3730 |  32.9590 |        - |  480088 B |</span><br><span class=\"line\">| .NET Framework 4.8 | 10000  |   158,728.7 ns |  2,151.48 ns |  1,907.23 ns |   158,243.9 ns |    0.07 |  76.4160 |  12.4512 |        - |  481511 B |</span><br><span class=\"line\">| .NET 8.0           | 100000 | 2,295,939.2 ns | 44,598.15 ns | 62,520.38 ns | 2,288,468.0 ns |    0.13 | 570.3125 | 535.1563 |        - | 4800090 B |</span><br><span class=\"line\">| .NET Framework 4.8 | 100000 | 3,632,195.6 ns | 49,765.42 ns | 46,550.60 ns | 3,633,088.3 ns |    0.08 | 757.8125 | 375.0000 |        - | 4814292 B |</span><br></pre></td></tr></table></figure>\n\n<p>On average, .NET 8 is 51% faster than .NET Framework 4.8, a clear demonstration how performance has improved over the years.</p>\n<h1 id=\"Analyzing-the-results\"><a href=\"#Analyzing-the-results\" class=\"headerlink\" title=\"Analyzing the results\"></a>Analyzing the results</h1><p>Now that we have the results you are probably questioning why does a <code>LinkedList</code> use more memory and is slower than <code>ToArray</code>? Since we don’t know the collection size, shouldn’t the constant allocation of new arrays and then a final copy to a trimmed one be slower and take more memory?</p>\n<p>Using more memory could actually be expectable since a <code>LinkedList</code>, for each item, creates a class that holds a reference for the previous and next node, but why is it slower since adding an item is always a O(1) operation?</p>\n<p>Based on personal experience, most developers I questioned about the <code>ToArray</code> implementation assume the following code (<a href=\"https://stackoverflow.com/a/16323412/1841558\">I actually believe this Stack Overflow response is to blame</a>):</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> T[] <span class=\"title\">ToArray</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">IEnumerable&lt;T&gt; items</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">int</span> sizeIncrease = <span class=\"number\">8</span>; <span class=\"comment\">// some arbitrary size increase</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> current = <span class=\"keyword\">new</span> T[sizeIncrease];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> item <span class=\"keyword\">in</span> items)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count == current.Length)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> previous = current;</span><br><span class=\"line\">            current = <span class=\"keyword\">new</span> T[previous.Length + sizeIncrease];</span><br><span class=\"line\">            previous.CopyTo(current, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        current[count++] = item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count <span class=\"keyword\">is</span> <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Array.Empty&lt;T&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    Array.Resize(<span class=\"keyword\">ref</span> current, count);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> current;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>It assumes the <code>ToArray</code> method behaves similar to a <code>List</code>, creating a bigger one every time the current is full and doing a copy, and in the end it trims the excess.</p>\n<p>In reality, the implementation is more similar to this:</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> T[] <span class=\"title\">ToArray</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">IEnumerable&lt;T&gt; items</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">int</span> sizeIncrease = <span class=\"number\">8</span>; <span class=\"comment\">// some arbitrary size increase</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> arrayBuffer = <span class=\"keyword\">new</span> Queue&lt;T[]&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> current = <span class=\"keyword\">new</span> T[sizeIncrease];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> idx = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> item <span class=\"keyword\">in</span> items)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (idx == sizeIncrease)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            arrayBuffer.Enqueue(current);</span><br><span class=\"line\">            current = <span class=\"keyword\">new</span> T[sizeIncrease];</span><br><span class=\"line\">            idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        current[idx++] = item;</span><br><span class=\"line\">        ++count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count <span class=\"keyword\">is</span> <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Array.Empty&lt;T&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentIdx = idx;</span><br><span class=\"line\"></span><br><span class=\"line\">    idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> final = <span class=\"keyword\">new</span> T[count];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (arrayBuffer.Count &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> previous = arrayBuffer.Dequeue();</span><br><span class=\"line\">        previous.CopyTo(final, idx);</span><br><span class=\"line\">        idx += previous.Length;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Array.Copy(current, <span class=\"number\">0</span>, final, idx, currentIdx);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> final;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Instead of creating a bigger array every time it’s full and copying all items, it actually creates a buffer that stores the previously allocated arrays and when the iteration finishes it copies everything in sequence to the final array that has the expected size.</p>\n<p>The actual <code>ToArray</code> method implementation as a lot of optimizations, for example, when an <code>ICollection</code> is received they can initialize a new array with the collection size and just call <code>CopyTo</code>. It also doesn’t use a <code>Queue</code> to keep track of previous initialized arrays but instead a simple version of a <code>LinkedList</code> concept.</p>\n<p>Give a look to the internal classes <a href=\"https://github.com/dotnet/runtime/blob/main/src/libraries/Common/src/System/Collections/Generic/EnumerableHelpers.cs\">EnumerableHelpers</a> and <a href=\"https://github.com/dotnet/runtime/blob/main/src/libraries/Common/src/System/Collections/Generic/ArrayBuilder.cs\">ArrayBuilder</a> for more implementation details.</p>\n<h1 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h1><p>In this article we compared the performance of initializing a <code>LinkedList</code> versus using <code>ToArray</code> and concluded that, on theory, <code>LinkedList</code> looked like a good fit when creating short lived collections were enumeration must be forced because of its O(1) nature when appending values, but due to internal optimizations of <code>ToArray</code> and since indexing is just faster while using less memory it significantly compensates having to allocate multiple arrays and copying their content.</p>\n<p>Keep in mind that <code>LinkedList</code> still has its place, specially when storing collections too big to be stored into a single memory section and it’s nice to see that .NET keeps improving its performance.</p>\n",
            "tags": [
                "dotnetcore",
                "csharp",
                "dotnet",
                "linq"
            ]
        },
        {
            "id": "https://code-corner.dev/2023/11/09/NET-%E2%80%94-ToList-vs-ToArray/",
            "url": "https://code-corner.dev/2023/11/09/NET-%E2%80%94-ToList-vs-ToArray/",
            "title": ".NET — ToList vs ToArray",
            "date_published": "2023-11-09T00:00:00.000Z",
            "content_html": "<p>Ever since Microsoft introduced Language Integrated Query to the .NET framework (also known as LINQ) developers have been using it extensively to work with collections.</p>\n<p>From a simple filter, to an aggregation, to a transformation, LINQ is the technology of choice to keep code clean and readable. We even have providers that convert LINQ instructions into SQL commands that will be run in some database.</p>\n<p>In this article I’m going to compare the performance of <code>ToList</code> versus <code>ToArray</code> when creating short lived collections. I’m also going to execute the test in different versions of the framework (.NET Framework 4.8, .NET 7 and .NET 8) so we can also see how much the performance have improved over the years.</p>\n<hr>\n<p>One of the coding guidelines for the applications I manage dictates the following:</p>\n<p><strong>Always use <code>IReadOnlyCollection</code> instead of <code>IEnumerable</code> when passing collections between application layers and <code>ToArray</code> should be used to force the enumeration.</strong></p>\n<p>Because we developers are curious by default and need to understand why things are implemented in a given way, every time we have a new team member, that coding guideline usually leads to the following conversation:</p>\n<p><strong>Q:</strong> <em>Why do we use <code>IReadOnlyCollection</code> in POCOs instead of <code>IEnumerable</code>?</em><br><strong>A:</strong> <em>Well, because we want the contracts to clearly state the collection is in memory, hence no multiple enumerations will occur, and any mapping problems will happen in the corresponding layer.</em><br><strong>Q:</strong> <em>Fair enough, but why <code>ToArray</code>? That interface is implemented by arrays and lists, I could be using <code>ToList</code> and have the same result.</em><br><strong>A:</strong> <em>The result is the same, that’s a fact, but <code>ToArray</code> is usually faster and more memory efficient than <code>ToList</code>, and since it’s a short lived collection that won’t be mutated, the former is preferred.</em></p>\n<p>I’m going to use the well known C# library <code>BenchmarkDotNet</code> to run the tests and the environment will be the following:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BenchmarkDotNet v0.13.10, Windows 11 (10.0.22621.2428/22H2/2022Update/SunValley2)</span><br><span class=\"line\">AMD Ryzen 7 3700X, 1 CPU, 16 logical and 8 physical cores</span><br><span class=\"line\">.NET SDK 8.0.100-rc.2.23502.2</span><br><span class=\"line\">  [Host]             : .NET 8.0.0 (8.0.23.47906), X64 RyuJIT AVX2</span><br><span class=\"line\">  .NET 5.0           : .NET 5.0.17 (5.0.1722.21314), X64 RyuJIT AVX2</span><br><span class=\"line\">  .NET 7.0           : .NET 7.0.11 (7.0.1123.42427), X64 RyuJIT AVX2</span><br><span class=\"line\">  .NET 8.0           : .NET 8.0.0 (8.0.23.47906), X64 RyuJIT AVX2</span><br><span class=\"line\">  .NET Framework 4.8 : .NET Framework 4.8.1 (4.8.9181.0), X64 RyuJIT VectorSize=256</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Performance-test\"><a href=\"#Performance-test\" class=\"headerlink\" title=\"Performance test\"></a>Performance test</h1><p>The test consists in the creation of a collection that holds random integers, being the size defined by a parameter. To ensure the randomness does not affect the results, the values are cached into an array and before invoking either <code>ToArray</code> or <code>ToList</code> it is converted into a new <code>IEnumerable</code>, not just a cast that could lead to internal optimizations.</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">SimpleJob(RuntimeMoniker.Net48)</span>]</span><br><span class=\"line\">[<span class=\"meta\">SimpleJob(RuntimeMoniker.Net70)</span>]</span><br><span class=\"line\">[<span class=\"meta\">SimpleJob(RuntimeMoniker.Net80)</span>]</span><br><span class=\"line\">[<span class=\"meta\">MemoryDiagnoser</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">ToListVsToArray</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"meta\">Params(10, 100, 1000, 10000, 100000)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> Size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">int</span>[] _items;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">GlobalSetup</span>]</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Setup</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> random = <span class=\"keyword\">new</span> Random(<span class=\"number\">123</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        _items = Enumerable.Range(<span class=\"number\">0</span>, Size).Select(_ =&gt; random.Next()).ToArray();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Benchmark</span>]</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span>[] <span class=\"title\">ToArray</span>()</span> =&gt; CreateItemsEnumerable().ToArray();</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Benchmark</span>]</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;<span class=\"built_in\">int</span>&gt; <span class=\"title\">ToList</span>()</span> =&gt; CreateItemsEnumerable().ToList();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> IEnumerable&lt;<span class=\"built_in\">int</span>&gt; <span class=\"title\">CreateItemsEnumerable</span>()</span> =&gt; _items.Select(e =&gt; e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Performance-results\"><a href=\"#Performance-results\" class=\"headerlink\" title=\"Performance results\"></a>Performance results</h1><p>Because we want to decide, for a given application, between ToArray or ToList based on performance, let’s first analyze the results for each framework version.</p>\n<h2 id=\"NET-Framework-4-8\"><a href=\"#NET-Framework-4-8\" class=\"headerlink\" title=\".NET Framework 4.8\"></a>.NET Framework 4.8</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| Method  | Size   | Mean          | Error        | StdDev       | Gen0     | Gen1     | Gen2     | Allocated |</span><br><span class=\"line\">|-------- |------- |--------------:|-------------:|-------------:|---------:|---------:|---------:|----------:|</span><br><span class=\"line\">| ToArray | 10     |     166.31 ns |     1.013 ns |     0.947 ns |   0.0484 |        - |        - |     305 B |</span><br><span class=\"line\">| ToList  | 10     |     193.17 ns |     1.248 ns |     1.168 ns |   0.0446 |        - |        - |     281 B |</span><br><span class=\"line\">| ToArray | 100    |     965.26 ns |     8.436 ns |     7.479 ns |   0.2594 |        - |        - |    1637 B |</span><br><span class=\"line\">| ToList  | 100    |   1,032.99 ns |     4.144 ns |     3.876 ns |   0.1984 |        - |        - |    1252 B |</span><br><span class=\"line\">| ToArray | 1000   |   8,377.61 ns |    39.382 ns |    36.838 ns |   1.9836 |        - |        - |   12509 B |</span><br><span class=\"line\">| ToList  | 1000   |   8,665.62 ns |    57.777 ns |    54.045 ns |   1.3428 |   0.0153 |        - |    8514 B |</span><br><span class=\"line\">| ToArray | 10000  |  81,576.33 ns |   923.478 ns |   863.822 ns |  26.9775 |   5.3711 |        - |  171755 B |</span><br><span class=\"line\">| ToList  | 10000  |  83,476.64 ns |   410.694 ns |   342.948 ns |  20.7520 |   4.0283 |        - |  131606 B |</span><br><span class=\"line\">| ToArray | 100000 | 830,624.20 ns | 4,536.991 ns | 4,021.924 ns | 399.4141 | 399.4141 | 399.4141 | 1452144 B |</span><br><span class=\"line\">| ToList  | 100000 | 945,017.84 ns | 7,921.731 ns | 6,615.004 ns | 285.1563 | 285.1563 | 285.1563 | 1051184 B |</span><br></pre></td></tr></table></figure>\n\n<p>The <code>ToArray</code> method is, on average, 10% faster than <code>ToList</code> in .NET Framework 4.8.</p>\n<h2 id=\"NET-7\"><a href=\"#NET-7\" class=\"headerlink\" title=\".NET 7\"></a>.NET 7</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| Method  | Size   | Mean          | Error        | StdDev       | Gen0     | Gen1     | Gen2     | Allocated |</span><br><span class=\"line\">|-------- |------- |--------------:|-------------:|-------------:|---------:|---------:|---------:|----------:|</span><br><span class=\"line\">| ToArray | 10     |      50.06 ns |     0.916 ns |     1.254 ns |   0.0134 |        - |        - |     112 B |</span><br><span class=\"line\">| ToList  | 10     |      56.20 ns |     1.022 ns |     0.906 ns |   0.0172 |        - |        - |     144 B |</span><br><span class=\"line\">| ToArray | 100    |     231.18 ns |     1.597 ns |     1.494 ns |   0.0563 |        - |        - |     472 B |</span><br><span class=\"line\">| ToList  | 100    |     261.38 ns |     2.523 ns |     2.236 ns |   0.0601 |        - |        - |     504 B |</span><br><span class=\"line\">| ToArray | 1000   |   2,029.47 ns |    28.534 ns |    25.295 ns |   0.4845 |        - |        - |    4072 B |</span><br><span class=\"line\">| ToList  | 1000   |   2,291.63 ns |    13.328 ns |    11.815 ns |   0.4883 |        - |        - |    4104 B |</span><br><span class=\"line\">| ToArray | 10000  |  17,322.99 ns |   176.548 ns |   165.143 ns |   4.7607 |        - |        - |   40072 B |</span><br><span class=\"line\">| ToList  | 10000  |  22,781.69 ns |   200.720 ns |   177.933 ns |   4.7607 |        - |        - |   40104 B |</span><br><span class=\"line\">| ToArray | 100000 | 306,976.29 ns | 2,525.016 ns | 2,361.901 ns | 124.5117 | 124.5117 | 124.5117 |  400114 B |</span><br><span class=\"line\">| ToList  | 100000 | 337,437.79 ns | 2,441.397 ns | 2,283.684 ns | 124.5117 | 124.5117 | 124.5117 |  400146 B |</span><br></pre></td></tr></table></figure>\n\n<p>The <code>ToArray</code> method is, on average, 13% faster than <code>ToList</code> in .NET 7.</p>\n<h2 id=\"NET-8\"><a href=\"#NET-8\" class=\"headerlink\" title=\".NET 8\"></a>.NET 8</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| Method  | Size   | Mean          | Error        | StdDev       | Gen0     | Gen1     | Gen2     | Allocated |</span><br><span class=\"line\">|-------- |------- |--------------:|-------------:|-------------:|---------:|---------:|---------:|----------:|</span><br><span class=\"line\">| ToArray | 10     |      33.89 ns |     0.727 ns |     0.778 ns |   0.0134 |        - |        - |     112 B |</span><br><span class=\"line\">| ToList  | 10     |      40.17 ns |     0.668 ns |     0.625 ns |   0.0172 |        - |        - |     144 B |</span><br><span class=\"line\">| ToArray | 100    |      90.30 ns |     1.104 ns |     0.922 ns |   0.0564 |        - |        - |     472 B |</span><br><span class=\"line\">| ToList  | 100    |      97.87 ns |     1.257 ns |     1.176 ns |   0.0602 |        - |        - |     504 B |</span><br><span class=\"line\">| ToArray | 1000   |     615.97 ns |     6.819 ns |     5.695 ns |   0.4864 |        - |        - |    4072 B |</span><br><span class=\"line\">| ToList  | 1000   |     615.44 ns |     5.195 ns |     4.056 ns |   0.4902 |        - |        - |    4104 B |</span><br><span class=\"line\">| ToArray | 10000  |   5,335.01 ns |    86.179 ns |    76.395 ns |   4.7607 |        - |        - |   40072 B |</span><br><span class=\"line\">| ToList  | 10000  |   5,427.51 ns |    86.063 ns |    80.503 ns |   4.7836 |        - |        - |   40104 B |</span><br><span class=\"line\">| ToArray | 100000 | 169,711.96 ns | 2,405.080 ns | 2,249.713 ns | 124.7559 | 124.7559 | 124.7559 |  400114 B |</span><br><span class=\"line\">| ToList  | 100000 | 162,577.72 ns | 1,634.437 ns | 1,364.829 ns | 124.7559 | 124.7559 | 124.7559 |  400146 B |</span><br></pre></td></tr></table></figure>\n\n<p>The <code>ToArray</code> method is, by a small margin, faster than <code>ToList</code> in .NET 8, being 4% slower on larger collections.</p>\n<h1 id=\"NET-performance-evolution\"><a href=\"#NET-performance-evolution\" class=\"headerlink\" title=\".NET performance evolution\"></a>.NET performance evolution</h1><p>Because we have results for each framework version, let’s compare and see how .NET performance has evolved over the years.</p>\n<h2 id=\"ToArray\"><a href=\"#ToArray\" class=\"headerlink\" title=\"ToArray\"></a>ToArray</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| Runtime            | Size   | Mean          | Error        | StdDev       | Gen0     | Gen1     | Gen2     | Allocated |</span><br><span class=\"line\">|------------------- |------- |--------------:|-------------:|-------------:|---------:|---------:|---------:|----------:|</span><br><span class=\"line\">| .NET Framework 4.8 | 10     |     166.31 ns |     1.013 ns |     0.947 ns |   0.0484 |        - |        - |     305 B |</span><br><span class=\"line\">| .NET 7.0           | 10     |      50.06 ns |     0.916 ns |     1.254 ns |   0.0134 |        - |        - |     112 B |</span><br><span class=\"line\">| .NET 8.0           | 10     |      33.89 ns |     0.727 ns |     0.778 ns |   0.0134 |        - |        - |     112 B |</span><br><span class=\"line\">| .NET Framework 4.8 | 100    |     965.26 ns |     8.436 ns |     7.479 ns |   0.2594 |        - |        - |    1637 B |</span><br><span class=\"line\">| .NET 7.0           | 100    |     231.18 ns |     1.597 ns |     1.494 ns |   0.0563 |        - |        - |     472 B |</span><br><span class=\"line\">| .NET 8.0           | 100    |      90.30 ns |     1.104 ns |     0.922 ns |   0.0564 |        - |        - |     472 B |</span><br><span class=\"line\">| .NET Framework 4.8 | 1000   |   8,377.61 ns |    39.382 ns |    36.838 ns |   1.9836 |        - |        - |   12509 B |</span><br><span class=\"line\">| .NET 7.0           | 1000   |   2,029.47 ns |    28.534 ns |    25.295 ns |   0.4845 |        - |        - |    4072 B |</span><br><span class=\"line\">| .NET 8.0           | 1000   |     615.97 ns |     6.819 ns |     5.695 ns |   0.4864 |        - |        - |    4072 B |</span><br><span class=\"line\">| .NET Framework 4.8 | 10000  |  81,576.33 ns |   923.478 ns |   863.822 ns |  26.9775 |   5.3711 |        - |  171755 B |</span><br><span class=\"line\">| .NET 7.0           | 10000  |  17,322.99 ns |   176.548 ns |   165.143 ns |   4.7607 |        - |        - |   40072 B |</span><br><span class=\"line\">| .NET 8.0           | 10000  |   5,335.01 ns |    86.179 ns |    76.395 ns |   4.7607 |        - |        - |   40072 B |</span><br><span class=\"line\">| .NET Framework 4.8 | 100000 | 830,624.20 ns | 4,536.991 ns | 4,021.924 ns | 399.4141 | 399.4141 | 399.4141 | 1452144 B |</span><br><span class=\"line\">| .NET 7.0           | 100000 | 306,976.29 ns | 2,525.016 ns | 2,361.901 ns | 124.5117 | 124.5117 | 124.5117 |  400114 B |</span><br><span class=\"line\">| .NET 8.0           | 100000 | 169,711.96 ns | 2,405.080 ns | 2,249.713 ns | 124.7559 | 124.7559 | 124.7559 |  400114 B |</span><br></pre></td></tr></table></figure>\n\n<p>In some cases being 90% faster than .NET Framework 4.8 and more than 50% faster than .NET 7 while allocating less memory, .NET 8 is a clear winner.</p>\n<h2 id=\"ToList\"><a href=\"#ToList\" class=\"headerlink\" title=\"ToList\"></a>ToList</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| Runtime            | Size   | Mean          | Error        | StdDev       | Gen0     | Gen1     | Gen2     | Allocated |</span><br><span class=\"line\">|------------------- |------- |--------------:|-------------:|-------------:|---------:|---------:|---------:|----------:|</span><br><span class=\"line\">| .NET Framework 4.8 | 10     |     193.17 ns |     1.248 ns |     1.168 ns |   0.0446 |        - |        - |     281 B |</span><br><span class=\"line\">| .NET 7.0           | 10     |      56.20 ns |     1.022 ns |     0.906 ns |   0.0172 |        - |        - |     144 B |</span><br><span class=\"line\">| .NET 8.0           | 10     |      40.17 ns |     0.668 ns |     0.625 ns |   0.0172 |        - |        - |     144 B |</span><br><span class=\"line\">| .NET Framework 4.8 | 100    |   1,032.99 ns |     4.144 ns |     3.876 ns |   0.1984 |        - |        - |    1252 B |</span><br><span class=\"line\">| .NET 7.0           | 100    |     261.38 ns |     2.523 ns |     2.236 ns |   0.0601 |        - |        - |     504 B |</span><br><span class=\"line\">| .NET 8.0           | 100    |      97.87 ns |     1.257 ns |     1.176 ns |   0.0602 |        - |        - |     504 B |</span><br><span class=\"line\">| .NET Framework 4.8 | 1000   |   8,665.62 ns |    57.777 ns |    54.045 ns |   1.3428 |   0.0153 |        - |    8514 B |</span><br><span class=\"line\">| .NET 7.0           | 1000   |   2,291.63 ns |    13.328 ns |    11.815 ns |   0.4883 |        - |        - |    4104 B |</span><br><span class=\"line\">| .NET 8.0           | 1000   |     615.44 ns |     5.195 ns |     4.056 ns |   0.4902 |        - |        - |    4104 B |</span><br><span class=\"line\">| .NET Framework 4.8 | 10000  |  83,476.64 ns |   410.694 ns |   342.948 ns |  20.7520 |   4.0283 |        - |  131606 B |</span><br><span class=\"line\">| .NET 7.0           | 10000  |  22,781.69 ns |   200.720 ns |   177.933 ns |   4.7607 |        - |        - |   40104 B |</span><br><span class=\"line\">| .NET 8.0           | 10000  |   5,427.51 ns |    86.063 ns |    80.503 ns |   4.7836 |        - |        - |   40104 B |</span><br><span class=\"line\">| .NET Framework 4.8 | 100000 | 945,017.84 ns | 7,921.731 ns | 6,615.004 ns | 285.1563 | 285.1563 | 285.1563 | 1051184 B |</span><br><span class=\"line\">| .NET 7.0           | 100000 | 337,437.79 ns | 2,441.397 ns | 2,283.684 ns | 124.5117 | 124.5117 | 124.5117 |  400146 B |</span><br><span class=\"line\">| .NET 8.0           | 100000 | 162,577.72 ns | 1,634.437 ns | 1,364.829 ns | 124.7559 | 124.7559 | 124.7559 |  400146 B |</span><br></pre></td></tr></table></figure>\n\n<p>Once again, .NET 8 takes the gold!</p>\n<h1 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h1><p>In this article we compared the performance of <code>ToArray</code> versus <code>ToList</code> and concluded the former performs better most of the time by being faster and more memory efficient, so consider using it when creating short lived collections were enumeration must be forced.</p>\n<p>We also concluded that .NET 8, the version still to be released, will bring fantastic performance upgrades in this regards. Not only it is significantly faster than the older versions, it also brings <code>ToArray</code> and <code>ToList</code> so close that it’s almost indifferent which method should be used.</p>\n",
            "tags": [
                "dotnetcore",
                "csharp",
                "dotnet",
                "linq"
            ]
        },
        {
            "id": "https://code-corner.dev/2023/11/08/NET-8-%E2%80%94-FrozenDictionary-performance/",
            "url": "https://code-corner.dev/2023/11/08/NET-8-%E2%80%94-FrozenDictionary-performance/",
            "title": ".NET 8 — FrozenDictionary performance",
            "date_published": "2023-11-08T00:00:00.000Z",
            "content_html": "<p>Microsoft’s upcoming release of .NET 8 will introduce a lot of <a href=\"https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-8\">new features</a> that will certainly be welcomed by the developer community, making it an even stronger framework for application development.</p>\n<p>One of those features is the namespace <code>System.Collections.Frozen</code> that introduces two new collections: <code>FrozenDictionary</code> and <code>FrozenSet</code>. These new types, <a href=\"https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-8#performance-focused-types\">as stated by Microsoft</a>, are focused in reducing the time of read operations at the expense of increasing initialization time of immutable collections. This makes them perfect for shared data that only needs to be populated a single time, like application configurations or cached data in-memory.</p>\n<p>In this article I’m going to benchmark the performance gains that can be achieved by using a <code>FrozenDictionary</code> instead of a <code>Dictionary</code> or an <code>ImmutableDictionary</code> to store shared data.</p>\n<p>I’m going to use the well known C# library <code>BenchmarkDotNet</code> to run the tests and the environment will be the following:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BenchmarkDotNet v0.13.10, Windows 11 (10.0.22621.2428/22H2/2022Update/SunValley2)</span><br><span class=\"line\">AMD Ryzen 7 3700X, 1 CPU, 16 logical and 8 physical cores</span><br><span class=\"line\">.NET SDK 8.0.100-rc.2.23502.2</span><br><span class=\"line\">  [Host]   : .NET 8.0.0 (8.0.23.47906), X64 RyuJIT AVX2</span><br><span class=\"line\">  .NET 8.0 : .NET 8.0.0 (8.0.23.47906), X64 RyuJIT AVX2</span><br></pre></td></tr></table></figure>\n\n<p>For the tests, I’m going to benchmark the method <code>TryGetValue</code>, with one for 100% key hits and another for 100% key misses, which should give the performance for both perfect and worse scenarios. The collections <code>FrozenDictionary</code>, <code>ImmutableDictionary</code> and <code>Dictionary</code> will be used with a parameter setting the size.</p>\n<hr>\n<h1 id=\"Scenario-1-—-all-keys-are-found\"><a href=\"#Scenario-1-—-all-keys-are-found\" class=\"headerlink\" title=\"Scenario 1 — all keys are found\"></a>Scenario 1 — all keys are found</h1><p>For this scenario I’m going to initialize a collection of unique keys, populate all three dictionaries accordingly and then run the <code>TryGetValue</code> for all keys returning the latest found using the <code>Dictionary</code> test as the baseline.</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">SimpleJob(RuntimeMoniker.Net80)</span>]</span><br><span class=\"line\">[<span class=\"meta\">MemoryDiagnoser</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">TryGetValueAllKeysFound</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"meta\">Params(10, 100, 1000, 10000, 100000)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> Size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">int</span>[] _keys;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Dictionary&lt;<span class=\"built_in\">int</span>, <span class=\"built_in\">int</span>&gt; _dictionary;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ImmutableDictionary&lt;<span class=\"built_in\">int</span>,<span class=\"built_in\">int</span>&gt; _immutableDictionary;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> FrozenDictionary&lt;<span class=\"built_in\">int</span>, <span class=\"built_in\">int</span>&gt; _frozenDictionary;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">GlobalSetup</span>]</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Setup</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> random = <span class=\"keyword\">new</span> Random(<span class=\"number\">123</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> uniqueKeys = <span class=\"keyword\">new</span> HashSet&lt;<span class=\"built_in\">int</span>&gt;(Size);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; Size; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">int</span> key;</span><br><span class=\"line\">            <span class=\"keyword\">do</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                key = random.Next();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (uniqueKeys.Contains(key));</span><br><span class=\"line\"></span><br><span class=\"line\">            uniqueKeys.Add(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        _dictionary = uniqueKeys.Select((key, idx) =&gt; (key, idx)).ToDictionary(e =&gt; e.key, e =&gt; e.idx);</span><br><span class=\"line\">        _immutableDictionary = uniqueKeys.Select((key, idx) =&gt; (key, idx)).ToImmutableDictionary(e =&gt; e.key, e =&gt; e.idx);</span><br><span class=\"line\">        _frozenDictionary = uniqueKeys.Select((key, idx) =&gt; (key, idx)).ToFrozenDictionary(e =&gt; e.key, e =&gt; e.idx);</span><br><span class=\"line\"></span><br><span class=\"line\">        _keys = uniqueKeys.ToArray();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Benchmark(Baseline = true)</span>]</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">Dictionary</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> latestValue = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> _keys)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_dictionary.TryGetValue(key, <span class=\"keyword\">out</span> <span class=\"keyword\">var</span> <span class=\"keyword\">value</span>))</span><br><span class=\"line\">                latestValue = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> latestValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Benchmark</span>]</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">ImmutableDictionary</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> latestValue = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> _keys)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_immutableDictionary.TryGetValue(key, <span class=\"keyword\">out</span> <span class=\"keyword\">var</span> <span class=\"keyword\">value</span>))</span><br><span class=\"line\">                latestValue = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> latestValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Benchmark</span>]</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">FrozenDictionary</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> latestValue = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> _keys)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_frozenDictionary.TryGetValue(key, <span class=\"keyword\">out</span> <span class=\"keyword\">var</span> <span class=\"keyword\">value</span>))</span><br><span class=\"line\">                latestValue = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> latestValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The benchmark results are the following:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| Method              | Size   | Mean             | Error          | StdDev        | Ratio | RatioSD | Allocated | Alloc Ratio |</span><br><span class=\"line\">|-------------------- |------- |-----------------:|---------------:|--------------:|------:|--------:|----------:|------------:|</span><br><span class=\"line\">| Dictionary          | 10     |         46.29 ns |       0.300 ns |      0.251 ns |  1.00 |    0.00 |         - |          NA |</span><br><span class=\"line\">| ImmutableDictionary | 10     |         35.53 ns |       0.320 ns |      0.283 ns |  0.77 |    0.01 |         - |          NA |</span><br><span class=\"line\">| FrozenDictionary    | 10     |         85.47 ns |       1.779 ns |      5.244 ns |  1.86 |    0.13 |         - |          NA |</span><br><span class=\"line\">|                     |        |                  |                |               |       |         |           |             |</span><br><span class=\"line\">| Dictionary          | 100    |        470.00 ns |       2.253 ns |      2.108 ns |  1.00 |    0.00 |         - |          NA |</span><br><span class=\"line\">| ImmutableDictionary | 100    |        736.28 ns |      14.637 ns |     31.820 ns |  1.57 |    0.07 |         - |          NA |</span><br><span class=\"line\">| FrozenDictionary    | 100    |        263.18 ns |       2.898 ns |      2.569 ns |  0.56 |    0.01 |         - |          NA |</span><br><span class=\"line\">|                     |        |                  |                |               |       |         |           |             |</span><br><span class=\"line\">| Dictionary          | 1000   |      4,993.04 ns |      27.440 ns |     22.913 ns |  1.00 |    0.00 |         - |          NA |</span><br><span class=\"line\">| ImmutableDictionary | 1000   |     29,174.27 ns |     493.738 ns |    461.843 ns |  5.85 |    0.10 |         - |          NA |</span><br><span class=\"line\">| FrozenDictionary    | 1000   |      2,841.24 ns |      30.283 ns |     28.326 ns |  0.57 |    0.01 |         - |          NA |</span><br><span class=\"line\">|                     |        |                  |                |               |       |         |           |             |</span><br><span class=\"line\">| Dictionary          | 10000  |     77,394.04 ns |     295.972 ns |    247.150 ns |  1.00 |    0.00 |         - |          NA |</span><br><span class=\"line\">| ImmutableDictionary | 10000  |    630,488.18 ns |   3,040.379 ns |  2,695.216 ns |  8.15 |    0.05 |       1 B |          NA |</span><br><span class=\"line\">| FrozenDictionary    | 10000  |     43,957.48 ns |     274.398 ns |    256.672 ns |  0.57 |    0.00 |         - |          NA |</span><br><span class=\"line\">|                     |        |                  |                |               |       |         |           |             |</span><br><span class=\"line\">| Dictionary          | 100000 |  1,126,207.11 ns |   5,941.069 ns |  5,266.603 ns |  1.00 |    0.00 |       1 B |        1.00 |</span><br><span class=\"line\">| ImmutableDictionary | 100000 | 11,194,516.67 ns | 106,626.230 ns | 99,738.242 ns |  9.94 |    0.12 |      12 B |       12.00 |</span><br><span class=\"line\">| FrozenDictionary    | 100000 |    806,004.77 ns |   5,670.946 ns |  5,304.606 ns |  0.72 |    0.01 |       1 B |        1.00 |</span><br></pre></td></tr></table></figure>\n\n<p>As you can see, except for very small collections, the <code>FrozenDictionary</code> is about 43% faster than using a <code>Dictionary</code>, much faster than an <code>ImmutableDictionary</code>, without allocating more memory.</p>\n<h1 id=\"Scenario-2-—-no-keys-are-found\"><a href=\"#Scenario-2-—-no-keys-are-found\" class=\"headerlink\" title=\"Scenario 2 — no keys are found\"></a>Scenario 2 — no keys are found</h1><p>For this scenario I’m going to initialize a collection of unique keys, populate all three dictionaries accordingly, convert all keys to negative numbers to ensure the lookups are all different but will never match, and then run the <code>TryGetValue</code> for all returning the latest found using the <code>Dictionary</code> test as the baseline.</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">SimpleJob(RuntimeMoniker.Net80)</span>]</span><br><span class=\"line\">[<span class=\"meta\">MemoryDiagnoser</span>]</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">TryGetValueNoKeysFound</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"meta\">Params(10, 100, 1000, 10000, 100000)</span>]</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> Size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">int</span>[] _keys;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Dictionary&lt;<span class=\"built_in\">int</span>, <span class=\"built_in\">int</span>&gt; _dictionary;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ImmutableDictionary&lt;<span class=\"built_in\">int</span>,<span class=\"built_in\">int</span>&gt; _immutableDictionary;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> FrozenDictionary&lt;<span class=\"built_in\">int</span>, <span class=\"built_in\">int</span>&gt; _frozenDictionary;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">GlobalSetup</span>]</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Setup</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> random = <span class=\"keyword\">new</span> Random(<span class=\"number\">123</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> uniqueKeys = <span class=\"keyword\">new</span> HashSet&lt;<span class=\"built_in\">int</span>&gt;(Size);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; Size; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">int</span> key;</span><br><span class=\"line\">            <span class=\"keyword\">do</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                key = random.Next();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (uniqueKeys.Contains(key));</span><br><span class=\"line\"></span><br><span class=\"line\">            uniqueKeys.Add(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        _dictionary = uniqueKeys.Select((key, idx) =&gt; (key, idx)).ToDictionary(e =&gt; e.key, e =&gt; e.idx);</span><br><span class=\"line\">        _immutableDictionary = uniqueKeys.Select((key, idx) =&gt; (key, idx)).ToImmutableDictionary(e =&gt; e.key, e =&gt; e.idx);</span><br><span class=\"line\">        _frozenDictionary = uniqueKeys.Select((key, idx) =&gt; (key, idx)).ToFrozenDictionary(e =&gt; e.key, e =&gt; e.idx);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// convert all keys to negative numbers to ensure no matches</span></span><br><span class=\"line\">        _keys = uniqueKeys.Select(key =&gt; -key).ToArray();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Benchmark(Baseline = true)</span>]</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">Dictionary</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> latestValue = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> _keys)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_dictionary.TryGetValue(key, <span class=\"keyword\">out</span> <span class=\"keyword\">var</span> <span class=\"keyword\">value</span>))</span><br><span class=\"line\">                latestValue = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> latestValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Benchmark</span>]</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">ImmutableDictionary</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> latestValue = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> _keys)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_immutableDictionary.TryGetValue(key, <span class=\"keyword\">out</span> <span class=\"keyword\">var</span> <span class=\"keyword\">value</span>))</span><br><span class=\"line\">                latestValue = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> latestValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"meta\">Benchmark</span>]</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">FrozenDictionary</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> latestValue = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> _keys)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_frozenDictionary.TryGetValue(key, <span class=\"keyword\">out</span> <span class=\"keyword\">var</span> <span class=\"keyword\">value</span>))</span><br><span class=\"line\">                latestValue = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> latestValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The benchmark results are the following:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| Method              | Size   | Mean            | Error        | StdDev       | Ratio | RatioSD | Allocated | Alloc Ratio |</span><br><span class=\"line\">|-------------------- |------- |----------------:|-------------:|-------------:|------:|--------:|----------:|------------:|</span><br><span class=\"line\">| Dictionary          | 10     |        37.13 ns |     0.740 ns |     0.823 ns |  1.00 |    0.00 |         - |          NA |</span><br><span class=\"line\">| ImmutableDictionary | 10     |        33.81 ns |     0.629 ns |     0.588 ns |  0.91 |    0.03 |         - |          NA |</span><br><span class=\"line\">| FrozenDictionary    | 10     |        19.16 ns |     0.129 ns |     0.114 ns |  0.51 |    0.01 |         - |          NA |</span><br><span class=\"line\">|                     |        |                 |              |              |       |         |           |             |</span><br><span class=\"line\">| Dictionary          | 100    |       396.11 ns |     2.697 ns |     2.522 ns |  1.00 |    0.00 |         - |          NA |</span><br><span class=\"line\">| ImmutableDictionary | 100    |       488.48 ns |     2.480 ns |     2.198 ns |  1.23 |    0.01 |         - |          NA |</span><br><span class=\"line\">| FrozenDictionary    | 100    |       218.70 ns |     1.530 ns |     1.431 ns |  0.55 |    0.00 |         - |          NA |</span><br><span class=\"line\">|                     |        |                 |              |              |       |         |           |             |</span><br><span class=\"line\">| Dictionary          | 1000   |     4,019.84 ns |    38.187 ns |    35.720 ns |  1.00 |    0.00 |         - |          NA |</span><br><span class=\"line\">| ImmutableDictionary | 1000   |     6,708.41 ns |    14.893 ns |    13.931 ns |  1.67 |    0.02 |         - |          NA |</span><br><span class=\"line\">| FrozenDictionary    | 1000   |     2,372.01 ns |    15.113 ns |    13.398 ns |  0.59 |    0.00 |         - |          NA |</span><br><span class=\"line\">|                     |        |                 |              |              |       |         |           |             |</span><br><span class=\"line\">| Dictionary          | 10000  |    83,803.51 ns |   232.996 ns |   206.545 ns |  1.00 |    0.00 |         - |          NA |</span><br><span class=\"line\">| ImmutableDictionary | 10000  |    88,593.46 ns |   763.681 ns |   714.347 ns |  1.06 |    0.01 |         - |          NA |</span><br><span class=\"line\">| FrozenDictionary    | 10000  |    29,071.40 ns |    85.885 ns |    76.135 ns |  0.35 |    0.00 |         - |          NA |</span><br><span class=\"line\">|                     |        |                 |              |              |       |         |           |             |</span><br><span class=\"line\">| Dictionary          | 100000 | 1,293,765.26 ns | 3,587.916 ns | 3,356.139 ns |  1.00 |    0.00 |       1 B |        1.00 |</span><br><span class=\"line\">| ImmutableDictionary | 100000 | 1,145,366.16 ns | 4,726.433 ns | 4,421.108 ns |  0.89 |    0.00 |       1 B |        1.00 |</span><br><span class=\"line\">| FrozenDictionary    | 100000 |   475,573.09 ns | 2,445.081 ns | 2,167.501 ns |  0.37 |    0.00 |         - |        0.00 |</span><br></pre></td></tr></table></figure>\n\n<p>As you can see, the <code>FrozenDictionary</code> is on average 47% faster than a <code>Dictionary</code> for all sizes and even uses less memory for bigger collections. The <code>ImmutableDictionary</code>, once again, is the worse performer.</p>\n<h1 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h1><p>Microsoft with the release of .NET 8 is, once again, providing a lot of performance improvements that developers can use in their applications.</p>\n<p>For this article in particular, if you are storing key-value reference data that is immutable, populated a single time and can be shared across your application, the <code>FrozenDictionary</code> may be a good option if performance is of concern.</p>\n<p>Soon I’ll also do a benchmark for <code>FrozenSet</code> which I expect should demonstrate similar results.</p>\n",
            "tags": [
                "dotnetcore",
                "csharp"
            ]
        }
    ]
}