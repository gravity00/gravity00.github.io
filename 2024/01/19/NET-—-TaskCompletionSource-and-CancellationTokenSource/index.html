<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQKP5TGHJ8"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQKP5TGHJ8")</script><title>.NET — TaskCompletionSource and CancellationTokenSource | code-corner.dev</title><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name="google-adsense-account" content="ca-pub-4671230649342120"><meta name="description" content="When Microsoft released .NET Framework 4.0 in April 2010, the Task Parallel Library (TPL) was introduced to help developers replace the previously used Asynchronous Programming Model (APM) pattern for"><meta property="og:type" content="article"><meta property="og:title" content=".NET — TaskCompletionSource and CancellationTokenSource"><meta property="og:url" content="https://code-corner.dev/2024/01/19/NET-%E2%80%94-TaskCompletionSource-and-CancellationTokenSource/index.html"><meta property="og:site_name" content="code-corner.dev"><meta property="og:description" content="When Microsoft released .NET Framework 4.0 in April 2010, the Task Parallel Library (TPL) was introduced to help developers replace the previously used Asynchronous Programming Model (APM) pattern for"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://code-corner.dev/2024/01/19/NET-%E2%80%94-TaskCompletionSource-and-CancellationTokenSource/00_header.png"><meta property="article:published_time" content="2024-01-19T00:00:00.000Z"><meta property="article:modified_time" content="2024-04-16T17:31:21.747Z"><meta property="article:author" content="João Simões"><meta property="article:tag" content="dotnetcore"><meta property="article:tag" content="csharp"><meta property="article:tag" content="dotnet"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://code-corner.dev/2024/01/19/NET-%E2%80%94-TaskCompletionSource-and-CancellationTokenSource/00_header.png"><meta name="twitter:creator" content="@JoaoPRSimoes"><link rel="shortcut icon" href="/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="manifest" href="/site.webmanifest"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css"><link rel="canonical" href="https://code-corner.dev/2024/01/19/NET-—-TaskCompletionSource-and-CancellationTokenSource/"><meta name="generator" content="Hexo 7.1.1"><link rel="sitemap" type="application/xml" title="Sitemap" href="/sitemap.xml,sitemap.txt"></head><body><div id="container"><div id="wrap"><header id="header"><div id="banner"></div><div id="header-outer" class="outer"><div id="header-title" class="inner"><h1 id="logo-wrap"><a href="/" id="logo">code-corner.dev</a></h1><h2 id="subtitle-wrap"><a href="/" id="subtitle">The place to learn about programming</a></h2></div><div id="header-inner" class="inner"><nav id="main-nav"><a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a> <a class="main-nav-link" href="/">Home</a> <a class="main-nav-link" href="/archives">Archives</a></nav><nav id="sub-nav"><a class="nav-icon" target="_blank" rel="noopener" href="https://github.com/gravity00"><span class="fa fa-github"></span></a> <a class="nav-icon" target="_blank" rel="noopener" href="https://twitter.com/JoaoPRSimoes"><span class="fa fa-twitter"></span></a> <a class="nav-icon" target="_blank" rel="noopener" href="https://joaoprsimoes.medium.com/"><span class="fa fa-medium"></span></a> <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a> <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a></nav><div id="search-form-wrap"><form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://code-corner.dev"></form></div></div></div></header><div class="outer"><section id="main"><article id="post-NET-—-TaskCompletionSource-and-CancellationTokenSource" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="/2024/01/19/NET-%E2%80%94-TaskCompletionSource-and-CancellationTokenSource/" class="article-date"><time class="dt-published" datetime="2024-01-19T00:00:00.000Z" itemprop="datePublished">2024-01-19</time></a><div class="article-category"><a class="article-category-link" href="/categories/concepts/">concepts</a></div></div><div class="article-inner"><header class="article-header"><h1 class="p-name article-title" itemprop="headline name">.NET — TaskCompletionSource and CancellationTokenSource</h1><h2 class="p-name article-subtitle">The importance of TCS and CTS for Task-based asynchronous programming</h2></header><div class="e-content article-entry" itemprop="articleBody"><a href="https://code-corner.dev/2024/01/19/NET-%E2%80%94-TaskCompletionSource-and-CancellationTokenSource/00_header.png" data-fancybox="gallery" data-caption><img src="https://code-corner.dev/2024/01/19/NET-%E2%80%94-TaskCompletionSource-and-CancellationTokenSource/00_header.png"></a><p>When Microsoft released .NET Framework 4.0 in April 2010, the <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</a> was introduced to help developers replace the previously used <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm">Asynchronous Programming Model (APM)</a> pattern for a <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/task-based-asynchronous-programming">Task-based asynchronous programming</a>.</p><p>Before the introduction of Tasks, when implementing asynchronous code, developers had to define two variations of the same method: one to begin the operation execution (convention: <code>BeginOperationName</code>), that would receive an optional callback to be invoked when completed, and another to wait for the operation to complete (convention: <code>EndOperationName</code>) and get the result or an exception, usually used inside the callback to prevent the main thread to be blocked.</p><hr><p>As an example, imagine a repository of cars with an asynchronous method for getting one by a given plate number, implemented using the APM pattern:</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICarRepository</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IAsyncResult <span class="title">BeginGetByPlateNumber</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">string</span> plateNumber,</span></span></span><br><span class="line"><span class="params"><span class="function">        AsyncCallback callback,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">object</span> state</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Car <span class="title">EndGetByPlateNumber</span>(<span class="params">IAsyncResult ar</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// non-blocking usage</span></span><br><span class="line">carRepository.BeginGetByPlateNumber(plateNumber, ar =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> car = carRepository.EndGetByPlateNumber(ar);</span><br><span class="line">&#125;, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// blocking usage</span></span><br><span class="line"><span class="keyword">var</span> ar = carRepository.BeginGetByPlateNumber(plateNumber, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">var</span> car = carRepository.EndGetByPlateNumber(ar);</span><br></pre></td></tr></table></figure><p>As you can see, creating two methods per operation is one of the most obvious and annoying disadvantages of the APM pattern, while the other is the need to implement your own wrapper for <code>IAsyncResult</code> so you can trigger the <code>WaitHandle</code> and invoke the callbacks when the operation completes.</p><p>Another disadvantage was the cancellation of running operations. If it was supported — and that’s a big if — there wasn’t a standardized pattern for developers to follow. Some would create another method for canceling (i.e. <code>CancelOperationName</code>) that receives an <code>IAsyncResult</code>, others would provide a method directly into the <code>IAsyncResult</code> and either return their own interface or require a cast, and others would simply ignore this feature due to sheer complexity.</p><p>Because Microsoft knew asynchronous programming was very important for the future of .NET, it decided to solve these problems by introducing the Task Parallel Library, making it easier for developers to add parallelism and concurrency to applications.</p><p>The Task Parallel Library has two central pieces:</p><ul><li>The <code>CancellationToken</code> is a structure commonly used in asynchronous methods and enables developers to register a callback that will be invoked if a cancellation is requested. This provides a standardized approach for implementing asynchronous operations that can be canceled mid execution by simply receiving a <code>CancellationToken</code> as a method parameter.</li><li>The <code>Task</code> and <code>Task&lt;T&gt;</code> are classes that merge both <code>IAsyncResult</code> and <code>AsyncCallback</code> concepts. Developers can return a Task and the caller would either register a callback with <code>ContinueWith</code>, for a non-blocking approach, or use the method <code>Wait/Result</code> and block the main thread until the <code>Task</code> was completed. This removes the need to have callback parameters and only a single method is needed instead of <code>BeginX/EndX</code> methods.<br>If we change the previous car repository example from APM pattern to use TPL, it would be much simpler:</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICarRepository</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Task&lt;Car&gt; <span class="title">GetByPlateNumberAsync</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">string</span> plateNumber,</span></span></span><br><span class="line"><span class="params"><span class="function">        CancellationToken ct</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// non-blocking usage</span></span><br><span class="line">carRepository.GetByPlateNumberAsync(</span><br><span class="line">    plateNumber,</span><br><span class="line">    CancellationToken.None</span><br><span class="line">).ContinueWith(t =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> car = t.Result;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// blocking usage</span></span><br><span class="line"><span class="keyword">var</span> car = carRepository.GetByPlateNumberAsync(</span><br><span class="line">    plateNumber,</span><br><span class="line">    CancellationToken.None</span><br><span class="line">).Result;</span><br></pre></td></tr></table></figure><p>Now that we have an idea about <code>Task</code>, <code>Task&lt;T&gt;</code>, <code>CancellationToken</code> and some of the reasons why Microsoft created the Task Parallel Library, let’s analyze two other important classes that aren’t commonly used but make all of this possible — <code>TaskCompletionSource</code> and <code>CancellationTokenSource</code>.</p><h1 id="TaskCompletionSource"><a href="#TaskCompletionSource" class="headerlink" title="TaskCompletionSource"></a>TaskCompletionSource</h1><p>The class <code>TaskCompletionSource</code> is used to create a <code>Task</code> and provides methods to mark it as completed in one from three possible states:</p><ul><li><strong>RanToCompletion</strong> — the methods <code>SetResult</code> or <code>TrySetResult</code> complete the task successfully and, in case of a <code>Task&lt;T&gt;</code>, the result can be retrieved;</li><li><strong>Canceled</strong> — the methods <code>SetCanceled</code> or <code>TrySetCanceled</code> mark the task as cancelled mid-execution. Waiting or retrieving the result will throw a <code>TaskCanceledException</code>;</li><li><strong>Faulted</strong> — the methods <code>SetException</code> or <code>TrySetException</code> mark the task as faulted and waiting or retrieving the result will throw the exception.</li></ul><p>With this class developers can easily implement Task-based asynchronous programming. On later versions of the .NET Framework it was widely used to convert classes implementing the APM pattern and, with an increase adoption of tasks, developers also started to migrate their own libs.</p><p>Let’s imagine the car repository was still implemented using the APM pattern and we wanted to create some extension methods for developers that prefer to use tasks.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICarRepository</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IAsyncResult <span class="title">BeginGetByPlateNumber</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">string</span> plateNumber,</span></span></span><br><span class="line"><span class="params"><span class="function">        AsyncCallback callback,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">object</span> state</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Car <span class="title">EndGetByPlateNumber</span>(<span class="params">IAsyncResult ar</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">CarRepositoryExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Task&lt;Car&gt; <span class="title">GetByPlateNumberAsync</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">this</span> ICarRepository repository,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">string</span> plateNumber</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> tcs = <span class="keyword">new</span> TaskCompletionSource&lt;Car&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// use callback for non-blocking approach</span></span><br><span class="line">        repository.BeginGetByPlateNumber(plateNumber, ar =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> car = repository.EndGetByPlateNumber(ar);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// no exception thrown, mark the task as completed successfully</span></span><br><span class="line">                tcs.SetResult(car);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// exception thrown, mark the task as faulted</span></span><br><span class="line">                tcs.SetException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tcs.Task;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>As you can see, we just converted <code>BeginX/EndX</code> methods to tasks in just a few lines without blocking the caller thread.</p><p>The <code>TaskCompletionSource</code> is also perfect to convert <strong>Event-based Asynchronous Pattern (EAP)</strong>. Imagine you have a class that represents a message queue and it provides two events — <code>OnMessageReceived</code> and <code>OnErrorReceived</code> — and a non-blocking method to send a message.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IMessageQueue</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">event</span> Action&lt;<span class="built_in">object</span>, OnMessageReceivedEventArgs&gt; OnMessageReceived;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">event</span> Action&lt;<span class="built_in">object</span>, OnErrorReceivedEventArgs&gt; OnErrorReceived;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Send</span>(<span class="params">Guid correlationId, JObject content</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OnMessageReceivedEventArgs</span> : <span class="title">EventArgs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Guid CorrelationId &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> JObject Content &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OnErrorReceivedEventArgs</span> : <span class="title">EventArgs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Guid CorrelationId &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Exception Exception &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Let’s say we wanted to create an extension method that sends a message and, without blocking the current thread, waits for a correlated response or exception to be received.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MessageQueueExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;JObject&gt; <span class="title">SendAsync</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">this</span> IMessageQueue queue,</span></span></span><br><span class="line"><span class="params"><span class="function">        Guid correlationId,</span></span></span><br><span class="line"><span class="params"><span class="function">        JObject content</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> tcs = <span class="keyword">new</span> TaskCompletionSource&lt;JObject&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// register the events before sending the message</span></span><br><span class="line">        queue.OnMessageReceived += OnMessageReceived;</span><br><span class="line">        queue.OnErrorReceived += OnErrorReceived;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            queue.Send(correlationId, content);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> tcs.Task;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// ensure events registration is always cleaned up</span></span><br><span class="line">            queue.OnMessageReceived -= OnMessageReceived;</span><br><span class="line">            queue.OnErrorReceived -= OnErrorReceived;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">OnMessageReceived</span>(<span class="params"><span class="built_in">object</span> _, OnMessageReceivedEventArgs args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (args.CorrelationId == correlationId) </span><br><span class="line">                tcs.TrySetResult(args.Content);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">OnErrorReceived</span>(<span class="params"><span class="built_in">object</span> _, OnErrorReceivedEventArgs args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (args.CorrelationId == correlationId) </span><br><span class="line">                tcs.TrySetException(args.Exception);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The approach is very similar to the APM pattern. We do a temporary registration into the relevant events, then invoke the action that can trigger those events and change the task state when callbacks are invoked. Just be sure registrations are properly cleaned up or else a memory leak will happen.</p><h1 id="CancellationTokenSource"><a href="#CancellationTokenSource" class="headerlink" title="CancellationTokenSource"></a>CancellationTokenSource</h1><p>The class <code>CancellationTokenSource</code> is used to create a <code>CancellationToken</code> that can be manually marked as canceled using the method <code>Cancel</code> or, to support timeout implementations, the <code>CancelAfter</code> methods that will schedule a cancellation after the specified time as passed.</p><p>Using the previously defined <code>GetByPlateNumberAsync</code> extension method, let’s change it first to support cancellation using a <code>CancellationToken</code>. Please note that some performance improvements could be made when detecting for cancellation, but this implementation is for simplicity:</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">CarRepositoryExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;Car&gt; <span class="title">GetByPlateNumberAsync</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">this</span> ICarRepository repository,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">string</span> plateNumber,</span></span></span><br><span class="line"><span class="params"><span class="function">        CancellationToken ct</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> tcs = <span class="keyword">new</span> TaskCompletionSource&lt;Car&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">using</span> <span class="keyword">var</span> _ = ct.Register(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// if the cancellation is triggered we try to cancel the task</span></span><br><span class="line">            tcs.TrySetCanceled(ct);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// use callback for non-blocking approach</span></span><br><span class="line">        repository.BeginGetByPlateNumber(plateNumber, ar =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> car = repository.EndGetByPlateNumber(ar);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// because the task may have been cancelled first we</span></span><br><span class="line">                <span class="comment">// must try to set a result or an exception will be thrown</span></span><br><span class="line">                tcs.TrySetResult(car);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// same, task may have been cancelled first so we try</span></span><br><span class="line">                <span class="comment">// to set an exception and mark it as faulted</span></span><br><span class="line">                tcs.TrySetException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> tcs.Task;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now that <code>GetByPlateNumberAsync</code> supports cancellation, if we wanted to limit the waiting for a response to a maximum of 5 seconds, a <code>CancellationTokenSource</code> could be used:</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">cts.CancelAfter(TimeSpan.FromSeconds(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ct = cts.Token;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if this operation takes more than 5 seconds to run</span></span><br><span class="line"><span class="comment">// a TaskCanceledException will be thrown</span></span><br><span class="line"><span class="keyword">await</span> carRepository.GetByPlateNumberAsync(plateNumber, ct);</span><br></pre></td></tr></table></figure><p>The <code>CancellationTokenSource</code> also supports to be linked to an existing <code>CancellationToken</code> meaning that the underlying token can either be cancelled manually or by the linked token. This is usually useful to implement methods that offer some kind of timeout parameter without the caller having to use a <code>CancellationTokenSource</code> directly.</p><p>Let’s change the previously defined <code>SendAsync</code> extension method to support both cancellation using a token or a timeout parameter that will throw a <code>TimeoutException</code> if the waiting time is exceeded:</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MessageQueueExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;JObject&gt; <span class="title">SendAsync</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">this</span> IMessageQueue queue,</span></span></span><br><span class="line"><span class="params"><span class="function">        Guid correlationId,</span></span></span><br><span class="line"><span class="params"><span class="function">        JObject content,</span></span></span><br><span class="line"><span class="params"><span class="function">        TimeSpan timeout,</span></span></span><br><span class="line"><span class="params"><span class="function">        CancellationToken ct</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> tcs = <span class="keyword">new</span> TaskCompletionSource&lt;JObject&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> cts = CancellationTokenSource.CreateLinkedTokenSource(ct);</span><br><span class="line">        cts.CancelAfter(timeout);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">using</span> <span class="keyword">var</span> _ = cts.Token.Register(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ct.IsCancellationRequested)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// if ct was cancelled we want to throw a TaskCanceledException</span></span><br><span class="line">                tcs.TrySetCanceled(ct);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if ct wasn&#x27;t cancelled but the cts token was triggered</span></span><br><span class="line">            <span class="comment">// it can only mean the timeout parameter was exceeded</span></span><br><span class="line">            tcs.TrySetException(<span class="keyword">new</span> TimeoutException(</span><br><span class="line">                <span class="string">$&quot;The queue took more than &#x27;<span class="subst">&#123;timeout&#125;</span>&#x27; to return a message&quot;</span></span><br><span class="line">            ));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        queue.OnMessageReceived += OnMessageReceived;</span><br><span class="line">        queue.OnErrorReceived += OnErrorReceived;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            queue.Send(correlationId, content);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> tcs.Task;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            queue.OnMessageReceived -= OnMessageReceived;</span><br><span class="line">            queue.OnErrorReceived -= OnErrorReceived;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">OnMessageReceived</span>(<span class="params"><span class="built_in">object</span> _, OnMessageReceivedEventArgs args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (args.CorrelationId == correlationId) </span><br><span class="line">                tcs.TrySetResult(args.Content);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">OnErrorReceived</span>(<span class="params"><span class="built_in">object</span> _, OnErrorReceivedEventArgs args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (args.CorrelationId == correlationId) </span><br><span class="line">                tcs.TrySetException(args.Exception);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this case, we now use the method <code>CreateLinkedTokenSource</code> to ensure the <code>CancellationTokenSource</code> token will be cancelled if the <code>ct</code> parameter is cancelled or if a given timeout has passed. Because we are listening for the linked <code>cts</code> token, inside the callback we must check if the <code>ct</code> parameter was the cause of cancellation so we can either mark the task as canceled or faulted with a <code>TimeoutException</code>.</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>In this article I explained some of the reasons why Microsoft decided to replace the <strong>Asynchronous Programming Model (APM)</strong> pattern for the <strong>Task-based Asynchronous Programming</strong>, which is possible by using classes from the <strong>Task Parallel Library (TPL)</strong>.</p><p>I also demonstrated how the classes <code>TaskCompletionSource</code> and <code>CancellationTokenSource</code> could be used to convert any asynchronous implementation to tasks, even if based on <strong>Event-based Asynchronous Pattern (EAP)</strong>, ensuring threads won’t be blocked waiting for responses and even supporting the cancellation of running operations.</p></div><footer class="article-footer"><a data-url="https://code-corner.dev/2024/01/19/NET-%E2%80%94-TaskCompletionSource-and-CancellationTokenSource/" data-id="clv2o3ycq000njojh6oum1idw" data-title=".NET — TaskCompletionSource and CancellationTokenSource" class="article-share-link"><span class="fa fa-share">Share</span></a><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/csharp/" rel="tag">csharp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dotnet/" rel="tag">dotnet</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dotnetcore/" rel="tag">dotnetcore</a></li></ul></footer></div><nav id="article-nav"><a href="/2024/02/05/NET-%E2%80%94-LinkedList-vs-ToArray/" id="article-nav-newer" class="article-nav-link-wrap"><strong class="article-nav-caption">Newer</strong><div class="article-nav-title">.NET — LinkedList vs ToArray</div></a><a href="/2024/01/08/Dispose-pattern-in-NET/" id="article-nav-older" class="article-nav-link-wrap"><strong class="article-nav-caption">Older</strong><div class="article-nav-title">Dispose pattern in .NET</div></a></nav></article></section><aside id="sidebar"><div class="widget-wrap"><h3 class="widget-title">Categories</h3><div class="widget"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/concepts/">concepts</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/devops/">devops</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/performance/">performance</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tutorial/">tutorial</a><span class="category-list-count">9</span></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">Tags</h3><div class="widget"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/aspnetcore/" rel="tag">aspnetcore</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/csharp/" rel="tag">csharp</a><span class="tag-list-count">19</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dapper/" rel="tag">dapper</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dotnet/" rel="tag">dotnet</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dotnetcore/" rel="tag">dotnetcore</a><span class="tag-list-count">21</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/efcore/" rel="tag">efcore</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hangfire/" rel="tag">hangfire</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linq/" rel="tag">linq</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/patterns/" rel="tag">patterns</a><span class="tag-list-count">6</span></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">Tag Cloud</h3><div class="widget tagcloud"><a href="/tags/aspnetcore/" style="font-size:15px">aspnetcore</a> <a href="/tags/csharp/" style="font-size:18.33px">csharp</a> <a href="/tags/dapper/" style="font-size:10px">dapper</a> <a href="/tags/dotnet/" style="font-size:16.67px">dotnet</a> <a href="/tags/dotnetcore/" style="font-size:20px">dotnetcore</a> <a href="/tags/efcore/" style="font-size:11.67px">efcore</a> <a href="/tags/hangfire/" style="font-size:10px">hangfire</a> <a href="/tags/linq/" style="font-size:11.67px">linq</a> <a href="/tags/patterns/" style="font-size:13.33px">patterns</a></div></div><div class="widget-wrap"><h3 class="widget-title">Archives</h3><div class="widget"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">February 2024</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a><span class="archive-list-count">1</span></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">Recent Posts</h3><div class="widget"><ul><li><a href="/2024/06/19/NET-9-ToList-vs-ToArray/">.NET 9 - ToList vs ToArray</a></li><li><a href="/2024/05/25/NET-IAsyncEnumerable-utility-extensions/">.NET - IAsyncEnumerable utility extensions</a></li><li><a href="/2024/04/14/NET-9-%E2%80%94-Exception-handling-performance/">.NET 9 — Exception handling performance</a></li><li><a href="/2024/02/29/NET-Hangfire/">.NET - Hangfire</a></li><li><a href="/2024/02/05/NET-%E2%80%94-LinkedList-vs-ToArray/">.NET — LinkedList vs ToArray</a></li></ul></div></div></aside></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner"><a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png"></a><br>All website licensed under <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a><br>&copy; 2024 João Simões<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></div></div></footer></div><nav id="mobile-nav"><a href="/" class="mobile-nav-link">Home</a> <a href="/archives" class="mobile-nav-link">Archives</a></nav><script src="/js/jquery-3.6.4.min.js"></script><script src="/fancybox/jquery.fancybox.min.js"></script><script src="/js/script.js"></script></div></body></html>