<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQKP5TGHJ8"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQKP5TGHJ8")</script><title>.NET - IAsyncEnumerable utility extensions | code-corner.dev</title><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name="google-adsense-account" content="ca-pub-4671230649342120"><meta name="description" content="With the introduction of async streams in .NET Core 3, represented by the interface IAsyncEnumerable&lt;T&gt;, and with a direct support in C# 8 to iterate using await foreach or easily implement a ne"><meta property="og:type" content="article"><meta property="og:title" content=".NET - IAsyncEnumerable utility extensions"><meta property="og:url" content="https://code-corner.dev/2024/05/25/NET-IAsyncEnumerable-utility-extensions/index.html"><meta property="og:site_name" content="code-corner.dev"><meta property="og:description" content="With the introduction of async streams in .NET Core 3, represented by the interface IAsyncEnumerable&lt;T&gt;, and with a direct support in C# 8 to iterate using await foreach or easily implement a ne"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://code-corner.dev/2024/05/25/NET-IAsyncEnumerable-utility-extensions/00_header.png"><meta property="article:published_time" content="2024-05-24T23:00:00.000Z"><meta property="article:modified_time" content="2024-05-25T09:42:58.767Z"><meta property="article:author" content="João Simões"><meta property="article:tag" content="dotnetcore"><meta property="article:tag" content="dotnet"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://code-corner.dev/2024/05/25/NET-IAsyncEnumerable-utility-extensions/00_header.png"><meta name="twitter:creator" content="@JoaoPRSimoes"><link rel="shortcut icon" href="/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="manifest" href="/site.webmanifest"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css"><link rel="canonical" href="https://code-corner.dev/2024/05/25/NET-IAsyncEnumerable-utility-extensions/"><meta name="generator" content="Hexo 7.1.1"><link rel="sitemap" type="application/xml" title="Sitemap" href="/sitemap.xml,sitemap.txt"></head><body><div id="container"><div id="wrap"><header id="header"><div id="banner"></div><div id="header-outer" class="outer"><div id="header-title" class="inner"><h1 id="logo-wrap"><a href="/" id="logo">code-corner.dev</a></h1><h2 id="subtitle-wrap"><a href="/" id="subtitle">The place to learn about programming</a></h2></div><div id="header-inner" class="inner"><nav id="main-nav"><a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a> <a class="main-nav-link" href="/">Home</a> <a class="main-nav-link" href="/archives">Archives</a></nav><nav id="sub-nav"><a class="nav-icon" target="_blank" rel="noopener" href="https://github.com/gravity00"><span class="fa fa-github"></span></a> <a class="nav-icon" target="_blank" rel="noopener" href="https://twitter.com/JoaoPRSimoes"><span class="fa fa-twitter"></span></a> <a class="nav-icon" target="_blank" rel="noopener" href="https://joaoprsimoes.medium.com/"><span class="fa fa-medium"></span></a> <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a> <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a></nav><div id="search-form-wrap"><form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://code-corner.dev"></form></div></div></div></header><div class="outer"><section id="main"><article id="post-NET-IAsyncEnumerable-utility-extensions" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"><a href="/2024/05/25/NET-IAsyncEnumerable-utility-extensions/" class="article-date"><time class="dt-published" datetime="2024-05-24T23:00:00.000Z" itemprop="datePublished">2024-05-25</time></a><div class="article-category"><a class="article-category-link" href="/categories/concepts/">concepts</a></div></div><div class="article-inner"><header class="article-header"><h1 class="p-name article-title" itemprop="headline name">.NET - IAsyncEnumerable utility extensions</h1><h2 class="p-name article-subtitle">Collection of utility extensions for async streams</h2></header><div class="e-content article-entry" itemprop="articleBody"><a href="https://code-corner.dev/2024/05/25/NET-IAsyncEnumerable-utility-extensions/00_header.png" data-fancybox="gallery" data-caption><img src="https://code-corner.dev/2024/05/25/NET-IAsyncEnumerable-utility-extensions/00_header.png"></a><p>With the introduction of async streams in .NET Core 3, represented by the interface <code>IAsyncEnumerable&lt;T&gt;</code>, and with a direct support in C# 8 to iterate using <code>await foreach</code> or easily implement a new asynchronous stream by defining async <code>IAsyncEnumerable&lt;T&gt;</code> as the method result and using <code>yield return/yield break</code> just like we did for <code>IEnumerable&lt;T&gt;</code>, Microsoft standardized the way .NET developers implement asynchronous streams.</p><p>Even if we don’t realize, we probably use async streams on a daily basis, from Entity Framework Core to ASP.NET Core, it has become an important part of .NET that is now widely adopted.<br>In this article I’m going to show some the most common scenarios I usually face when working directly with <code>IAsyncEnumerable&lt;T&gt;</code> and how I usually solve them.</p><hr><h1 id="Utility-extensions-for-async-streams"><a href="#Utility-extensions-for-async-streams" class="headerlink" title="Utility extensions for async streams"></a>Utility extensions for async streams</h1><p>When implementing an extension for an async stream there are a few guidelines to keep in mind.</p><p>Firstly, don’t validate function inputs (like null checks) inside the <code>async</code> method, but create a wrapper method instead that validates and then calls an internal implementation. This will keep the stack trace more clean, easy to analyze and lightweight.</p><p>Secondly, your code will surely need a <code>CancellationToken</code> but don’t define it in the public method signature even if it has a default value. To make developers life easier, instead of passing a <code>CancellationToken</code> to every method, Microsoft provides the extension method <code>WithCancellation</code> that can be used on any <code>IAsyncEnumerable</code> and if you use the attribute <code>EnumeratorCancellation</code> in your methods signature, the compiler will automatically use the cancellation token passed to the <code>WithCancellation</code> method to all your methods. If you define it as a parameter in your public signature it will cause confusion to the developer using it.</p><p>Imagine you were creating a simple <code>Where</code> extension to filter an async stream, to follow the guidelines it would be implemented as follows:</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">IAsyncEnumerable</span>&lt;<span class="title">T</span>&gt; <span class="title">Where</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">this</span> IAsyncEnumerable&lt;T&gt; source,</span></span></span><br><span class="line"><span class="params"><span class="function">    Func&lt;T, <span class="built_in">bool</span>&gt; predicate</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ArgumentNullException.ThrowIfNull(source);</span><br><span class="line">    ArgumentNullException.ThrowIfNull(predicate);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Core(source, predicate);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> IAsyncEnumerable&lt;T&gt; <span class="title">Core</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        IAsyncEnumerable&lt;T&gt; source,</span></span></span><br><span class="line"><span class="params"><span class="function">        Func&lt;T, <span class="built_in">bool</span>&gt; predicate,</span></span></span><br><span class="line"><span class="params"><span class="function">        [EnumeratorCancellation] CancellationToken ct = <span class="literal">default</span></span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> source.WithCancellation(ct))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (predicate(item))</span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">return</span> item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>As you can see, the validations are done outside the actual implementation just like the <code>CancellationToken</code> is only defined internally.</p><p>I recommend giving a good look to the <a target="_blank" rel="noopener" href="https://github.com/dotnet/reactive">source code</a> of <code>System.Linq.Async</code>, the officially supported LINQ extensions for async streams.</p><p>Let’s now drill down to some of my most used utility extensions.</p><h2 id="Timeout-between-fetches"><a href="#Timeout-between-fetches" class="headerlink" title="Timeout between fetches"></a>Timeout between fetches</h2><p>When receiving data from an <code>IAsyncEnumerable</code> we may not know how many items and how long in total it is going to take, but we may want to enforce a maximum timeout between receiving each item to ensure the application doesn’t wait indefinitely.</p><p>One very common scenario nowadays is the integration with Large Language Models (LLMs) APIs that use Server-Sent Events (SSE) to stream response tokens to be shown to the user in real time. Even with a loading somewhere, if some token response takes too long the user will probably think the application just stopped working.</p><p>The following code will link a <code>CancellationTokenSource</code> to the original <code>CancellationToken</code> and use it’s internal timer to automatically cancel after a given time as passed, throwing a <code>TaskCanceledException</code> when waiting for the next item.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">IAsyncEnumerable</span>&lt;<span class="title">T</span>&gt; <span class="title">Timeout</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">this</span> IAsyncEnumerable&lt;T&gt; source,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="built_in">int</span> millisecondsTimeout</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ArgumentNullException.ThrowIfNull(source);</span><br><span class="line">    ArgumentOutOfRangeException.ThrowIfLessThan(millisecondsTimeout, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Core(source, millisecondsTimeout);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> IAsyncEnumerable&lt;T&gt; <span class="title">Core</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        IAsyncEnumerable&lt;T&gt; source,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">int</span> millisecondsTimeout,</span></span></span><br><span class="line"><span class="params"><span class="function">        [EnumeratorCancellation] CancellationToken ct = <span class="literal">default</span></span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> cts = CancellationTokenSource.CreateLinkedTokenSource(ct);</span><br><span class="line">        cts.CancelAfter(millisecondsTimeout);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">foreach</span> (<span class="keyword">var</span> element <span class="keyword">in</span> source.WithCancellation(ct))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// disable the timer while the item is being processed</span></span><br><span class="line">            cts.CancelAfter(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> element;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// re-enable the timer before fetching the next item</span></span><br><span class="line">            cts.CancelAfter(millisecondsTimeout);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>I like this approach because it’s simple and, except for an extra allocation of a <code>CancellationTokenSource</code> and it’s internal <code>Timer</code> (which will be reused per item), there’s nothing much to be said making it a very efficient implementation. It can be use just like any LINQ method:</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> i <span class="keyword">in</span> <span class="title">GetRandomIntegersAsync</span>(<span class="params"><span class="number">20</span></span>)</span></span><br><span class="line"><span class="function">                   .<span class="title">Timeout</span>(<span class="params"><span class="number">500</span></span>)</span></span><br><span class="line"><span class="function">                   .<span class="title">WithCancellation</span>(<span class="params">ct</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;DateTimeOffset.Now:O&#125;</span> -&gt; <span class="subst">&#123;i&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If you are like me an prefer to receive a <code>TimeoutException</code>, you can change the implementation by manually iterating over the enumerator instead of using <code>await foreach</code> and if a <code>TaskCanceledException</code> is thrown but the received <code>CancellationToken</code> isn’t cancelled, you can assume it was due to a timeout and throw a <code>TimeoutException</code> instead.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">IAsyncEnumerable</span>&lt;<span class="title">T</span>&gt; <span class="title">Timeout</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">this</span> IAsyncEnumerable&lt;T&gt; source,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="built_in">int</span> millisecondsTimeout</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ArgumentNullException.ThrowIfNull(source);</span><br><span class="line">    ArgumentOutOfRangeException.ThrowIfLessThan(millisecondsTimeout, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Core(source, millisecondsTimeout);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> IAsyncEnumerable&lt;T&gt; <span class="title">Core</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        IAsyncEnumerable&lt;T&gt; source,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">int</span> millisecondsTimeout,</span></span></span><br><span class="line"><span class="params"><span class="function">        [EnumeratorCancellation] CancellationToken ct = <span class="literal">default</span></span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> cts = CancellationTokenSource.CreateLinkedTokenSource(ct);</span><br><span class="line">        cts.CancelAfter(millisecondsTimeout);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">using</span> <span class="keyword">var</span> enumerator = source.GetAsyncEnumerator(cts.Token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">await</span> MoveNextCheckTimeoutAsync(enumerator, ct))</span><br><span class="line">        &#123;</span><br><span class="line">            cts.CancelAfter(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> enumerator.Current;</span><br><span class="line"></span><br><span class="line">            cts.CancelAfter(millisecondsTimeout);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> ValueTask&lt;<span class="built_in">bool</span>&gt; <span class="title">MoveNextCheckTimeoutAsync</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        IAsyncEnumerator&lt;T&gt; enumerator,</span></span></span><br><span class="line"><span class="params"><span class="function">        CancellationToken ct</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> enumerator.MoveNextAsync();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TaskCanceledException e) <span class="keyword">when</span> (!ct.IsCancellationRequested)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(<span class="string">&quot;The next item took longer than expected to be received&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Batch-with-maximum-waiting-time"><a href="#Batch-with-maximum-waiting-time" class="headerlink" title="Batch with maximum waiting time"></a>Batch with maximum waiting time</h2><p>When receiving data from an <code>IAsyncEnumerable</code> to be persisted is some database, to reduce and optimize the insertion it may be a good idea to batch it instead of store item by item.</p><p>Imagine you are storing data into some relational table, if you receive 500 items, that’s 500 database accesses which may affect the performance of your overall application. If instead you create batches of 10 items it will mean 50 database accesses with more time in between, certainly reducing the overall database load.</p><p>If we use <a target="_blank" rel="noopener" href="https://morelinq.github.io/">MoreLINQ</a> <code>Batch</code> method as an example, we can easily convert it to an <code>IAsyncEnumerable</code> implementation.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">IAsyncEnumerable</span>&lt;<span class="title">T</span>[]&gt; <span class="title">Batch</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">this</span> IAsyncEnumerable&lt;T&gt; source,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="built_in">int</span> size</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ArgumentNullException.ThrowIfNull(source);</span><br><span class="line">    ArgumentOutOfRangeException.ThrowIfNegativeOrZero(size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Core(source, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> IAsyncEnumerable&lt;T[]&gt; Core(</span><br><span class="line">        IAsyncEnumerable&lt;T&gt; source,</span><br><span class="line">        <span class="built_in">int</span> size,</span><br><span class="line">        [<span class="meta">EnumeratorCancellation</span>] CancellationToken ct = <span class="literal">default</span></span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        T[] batch = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> source.WithCancellation(ct))</span><br><span class="line">        &#123;</span><br><span class="line">            batch ??= <span class="keyword">new</span> T[size];</span><br><span class="line">            batch[count++] = item;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count != size)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> batch;</span><br><span class="line">            batch = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Array.Resize(<span class="keyword">ref</span> batch, count);</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> batch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Another common scenario when batching items is to support a timeout parameter that will either return a complete batch or, after a given time has passed, it will return whatever items have already been received.</p><p>This can be easily implemented by calculating the a timeout date and check if it has passed every time a item is received. If the given amount of time has passed, you simply resize the collection to the current size, return that batch and calculate again the next timeout date.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">IAsyncEnumerable</span>&lt;<span class="title">T</span>[]&gt; <span class="title">Batch</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">this</span> IAsyncEnumerable&lt;T&gt; source,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="built_in">int</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="built_in">int</span> millisecondsTimeout</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ArgumentNullException.ThrowIfNull(source);</span><br><span class="line">    ArgumentOutOfRangeException.ThrowIfNegativeOrZero(size);</span><br><span class="line">    ArgumentOutOfRangeException.ThrowIfNegative(millisecondsTimeout);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Core(source, size, millisecondsTimeout);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> IAsyncEnumerable&lt;T[]&gt; Core(</span><br><span class="line">        IAsyncEnumerable&lt;T&gt; source,</span><br><span class="line">        <span class="built_in">int</span> size,</span><br><span class="line">        <span class="built_in">int</span> millisecondsTimeout,</span><br><span class="line">        [<span class="meta">EnumeratorCancellation</span>] CancellationToken ct = <span class="literal">default</span></span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        T[] batch = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> timeoutOn = DateTime.UtcNow.AddMilliseconds(millisecondsTimeout);</span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> source.WithCancellation(ct))</span><br><span class="line">        &#123;</span><br><span class="line">            batch ??= <span class="keyword">new</span> T[size];</span><br><span class="line">            batch[count++] = item;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count != size)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (timeoutOn &gt; DateTime.UtcNow) </span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                Array.Resize(<span class="keyword">ref</span> batch, count);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> batch;</span><br><span class="line"></span><br><span class="line">            batch = <span class="literal">null</span>;</span><br><span class="line">            timeoutOn = DateTime.UtcNow.AddMilliseconds(millisecondsTimeout);</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Array.Resize(<span class="keyword">ref</span> batch, count);</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> batch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>I like this approach because it is very simple to understand and efficient since it only allocates an extra <code>DateTime</code> over the initial batch method. The only downside is that it only timeouts after an item is received not while waiting. To solve that limitation, the implementation would require a timer and constant allocations of <code>TaskCompletitionSource</code> which, at least for my use cases, it isn’t worth the complexity and performance overload.</p><p>Again, this method can easily be used just like other LINQ extensions:</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> i <span class="keyword">in</span> <span class="title">GetRandomIntegersAsync</span>(<span class="params"><span class="number">20</span></span>)</span></span><br><span class="line"><span class="function">                   .<span class="title">Batch</span>(<span class="params"><span class="number">5</span>, <span class="number">1000</span></span>)</span></span><br><span class="line"><span class="function">                   .<span class="title">Where</span>(<span class="params">e =&gt; e.Length &gt; <span class="number">0</span></span>)</span></span><br><span class="line"><span class="function">                   .<span class="title">WithCancellation</span>(<span class="params">ct</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;DateTimeOffset.Now:O&#125;</span> -&gt; <span class="subst">&#123;i.Length&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Throttling"><a href="#Throttling" class="headerlink" title="Throttling"></a>Throttling</h2><p>One last scenario I usually face is to apply some throttling to prevent overloading the application in case of a high throughput of items received from <code>IAsyncEnumerable</code>. It usually combines very well with the timeout <code>Batch</code> method to enforce a predictive cadence of data.</p><p>The implementation is very simple: you calculate the timeout date, fetch the next item, and if not enough time has passed, you just do a delay for the remaining time and repeat the process per each item.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">IAsyncEnumerable</span>&lt;<span class="title">T</span>&gt; <span class="title">Throttling</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">this</span> IAsyncEnumerable&lt;T&gt; source,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="built_in">int</span> millisecondsDelay</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ArgumentNullException.ThrowIfNull(source);</span><br><span class="line">    ArgumentOutOfRangeException.ThrowIfNegative(millisecondsDelay);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Core(source, millisecondsDelay);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> IAsyncEnumerable&lt;T&gt; <span class="title">Core</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        IAsyncEnumerable&lt;T&gt; source,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">int</span> millisecondsDelay,</span></span></span><br><span class="line"><span class="params"><span class="function">        [EnumeratorCancellation] CancellationToken ct = <span class="literal">default</span></span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> timeoutOn = DateTime.UtcNow.AddMilliseconds(millisecondsDelay);</span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> source.WithCancellation(ct))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (DateTime.UtcNow &lt; timeoutOn) </span><br><span class="line">                <span class="keyword">await</span> Task.Delay(timeoutOn - DateTime.UtcNow, ct);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> item;</span><br><span class="line"></span><br><span class="line">            timeoutOn = DateTime.UtcNow.AddMilliseconds(millisecondsDelay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Once again, use it just like other LINQ extensions:</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> i <span class="keyword">in</span> <span class="title">GetRandomIntegersAsync</span>(<span class="params"><span class="number">20</span></span>)</span></span><br><span class="line"><span class="function">                   .<span class="title">Throttling</span>(<span class="params"><span class="number">5000</span></span>)</span></span><br><span class="line"><span class="function">                   .<span class="title">WithCancellation</span>(<span class="params">ct</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;DateTimeOffset.Now:O&#125;</span> -&gt; <span class="subst">&#123;i&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>In this article I’ve shown some of the most common utility methods I use when working with <code>IAsyncEnumerable</code>, allowing to either implement timeouts while waiting for the next item, batching with a maximum wait time or enforcing throttling to prevent application overload.</p><p>Feel free to change them in ways that make sense to you, like creating overloads that receive a <code>TimeSpan</code>, or use them as an example for creating your own utility methods.</p><p>Here’s the full code sample so you can put it in your own projects.</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">System.Collections.Generic</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">AsyncEnumerableExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">IAsyncEnumerable</span>&lt;<span class="title">T</span>&gt; <span class="title">Timeout</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">this</span> IAsyncEnumerable&lt;T&gt; source,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">int</span> millisecondsTimeout</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ArgumentNullException.ThrowIfNull(source);</span><br><span class="line">        ArgumentOutOfRangeException.ThrowIfLessThan(millisecondsTimeout, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Core(source, millisecondsTimeout);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> IAsyncEnumerable&lt;T&gt; <span class="title">Core</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">            IAsyncEnumerable&lt;T&gt; source,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="built_in">int</span> millisecondsTimeout,</span></span></span><br><span class="line"><span class="params"><span class="function">            [EnumeratorCancellation] CancellationToken ct = <span class="literal">default</span></span></span></span><br><span class="line"><span class="params"><span class="function">        </span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> cts = CancellationTokenSource.CreateLinkedTokenSource(ct);</span><br><span class="line">            cts.CancelAfter(millisecondsTimeout);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">await</span> <span class="keyword">using</span> <span class="keyword">var</span> enumerator = source.GetAsyncEnumerator(cts.Token);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">await</span> MoveNextCheckTimeoutAsync(enumerator, ct))</span><br><span class="line">            &#123;</span><br><span class="line">                cts.CancelAfter(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">return</span> enumerator.Current;</span><br><span class="line"></span><br><span class="line">                cts.CancelAfter(millisecondsTimeout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> <span class="title">ValueTask</span>&lt;<span class="title">bool</span>&gt; <span class="title">MoveNextCheckTimeoutAsync</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">            IAsyncEnumerator&lt;T&gt; enumerator,</span></span></span><br><span class="line"><span class="params"><span class="function">            CancellationToken ct</span></span></span><br><span class="line"><span class="params"><span class="function">        </span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">await</span> enumerator.MoveNextAsync();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (TaskCanceledException e) <span class="keyword">when</span> (!ct.IsCancellationRequested)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(<span class="string">&quot;The next item took longer than expected to be received&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">IAsyncEnumerable</span>&lt;<span class="title">T</span>[]&gt; <span class="title">Batch</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">this</span> IAsyncEnumerable&lt;T&gt; source,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">int</span> size</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ArgumentNullException.ThrowIfNull(source);</span><br><span class="line">        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Core(source, size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">async</span> IAsyncEnumerable&lt;T[]&gt; Core(</span><br><span class="line">            IAsyncEnumerable&lt;T&gt; source,</span><br><span class="line">            <span class="built_in">int</span> size,</span><br><span class="line">            [<span class="meta">EnumeratorCancellation</span>] CancellationToken ct = <span class="literal">default</span></span><br><span class="line">        )</span><br><span class="line">        &#123;</span><br><span class="line">            T[] batch = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">await</span> <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> source.WithCancellation(ct))</span><br><span class="line">            &#123;</span><br><span class="line">                batch ??= <span class="keyword">new</span> T[size];</span><br><span class="line">                batch[count++] = item;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (count != size)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">return</span> batch;</span><br><span class="line">                batch = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Array.Resize(<span class="keyword">ref</span> batch, count);</span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">return</span> batch;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">IAsyncEnumerable</span>&lt;<span class="title">T</span>[]&gt; <span class="title">Batch</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">this</span> IAsyncEnumerable&lt;T&gt; source,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">int</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">int</span> millisecondsTimeout</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ArgumentNullException.ThrowIfNull(source);</span><br><span class="line">        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(size);</span><br><span class="line">        ArgumentOutOfRangeException.ThrowIfNegative(millisecondsTimeout);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Core(source, size, millisecondsTimeout);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">async</span> IAsyncEnumerable&lt;T[]&gt; Core(</span><br><span class="line">            IAsyncEnumerable&lt;T&gt; source,</span><br><span class="line">            <span class="built_in">int</span> size,</span><br><span class="line">            <span class="built_in">int</span> millisecondsTimeout,</span><br><span class="line">            [<span class="meta">EnumeratorCancellation</span>] CancellationToken ct = <span class="literal">default</span></span><br><span class="line">        )</span><br><span class="line">        &#123;</span><br><span class="line">            T[] batch = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> timeoutOn = DateTime.UtcNow.AddMilliseconds(millisecondsTimeout);</span><br><span class="line">            <span class="keyword">await</span> <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> source.WithCancellation(ct))</span><br><span class="line">            &#123;</span><br><span class="line">                batch ??= <span class="keyword">new</span> T[size];</span><br><span class="line">                batch[count++] = item;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (count != size)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (timeoutOn &gt; DateTime.UtcNow) </span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                    Array.Resize(<span class="keyword">ref</span> batch, count);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">return</span> batch;</span><br><span class="line"></span><br><span class="line">                batch = <span class="literal">null</span>;</span><br><span class="line">                timeoutOn = DateTime.UtcNow.AddMilliseconds(millisecondsTimeout);</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Array.Resize(<span class="keyword">ref</span> batch, count);</span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">return</span> batch;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">IAsyncEnumerable</span>&lt;<span class="title">T</span>&gt; <span class="title">Throttling</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">this</span> IAsyncEnumerable&lt;T&gt; source,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">int</span> millisecondsDelay</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ArgumentNullException.ThrowIfNull(source);</span><br><span class="line">        ArgumentOutOfRangeException.ThrowIfNegative(millisecondsDelay);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Core(source, millisecondsDelay);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> IAsyncEnumerable&lt;T&gt; <span class="title">Core</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">            IAsyncEnumerable&lt;T&gt; source,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="built_in">int</span> millisecondsDelay,</span></span></span><br><span class="line"><span class="params"><span class="function">            [EnumeratorCancellation] CancellationToken ct = <span class="literal">default</span></span></span></span><br><span class="line"><span class="params"><span class="function">        </span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> timeoutOn = DateTime.UtcNow.AddMilliseconds(millisecondsDelay);</span><br><span class="line">            <span class="keyword">await</span> <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> source.WithCancellation(ct))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (DateTime.UtcNow &lt; timeoutOn) </span><br><span class="line">                    <span class="keyword">await</span> Task.Delay(timeoutOn - DateTime.UtcNow, ct);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">return</span> item;</span><br><span class="line"></span><br><span class="line">                timeoutOn = DateTime.UtcNow.AddMilliseconds(millisecondsDelay);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="article-footer"><a data-url="https://code-corner.dev/2024/05/25/NET-IAsyncEnumerable-utility-extensions/" data-id="clwlx88dj0000bojhgusoai2i" data-title=".NET - IAsyncEnumerable utility extensions" class="article-share-link"><span class="fa fa-share">Share</span></a><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dotnet/" rel="tag">dotnet</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dotnetcore/" rel="tag">dotnetcore</a></li></ul></footer></div><nav id="article-nav"><a href="/2024/06/19/NET-9-ToList-vs-ToArray/" id="article-nav-newer" class="article-nav-link-wrap"><strong class="article-nav-caption">Newer</strong><div class="article-nav-title">.NET 9 - ToList vs ToArray</div></a><a href="/2024/04/14/NET-9-%E2%80%94-Exception-handling-performance/" id="article-nav-older" class="article-nav-link-wrap"><strong class="article-nav-caption">Older</strong><div class="article-nav-title">.NET 9 — Exception handling performance</div></a></nav></article></section><aside id="sidebar"><div class="widget-wrap"><h3 class="widget-title">Categories</h3><div class="widget"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/concepts/">concepts</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/devops/">devops</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/performance/">performance</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tutorial/">tutorial</a><span class="category-list-count">9</span></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">Tags</h3><div class="widget"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/aspnetcore/" rel="tag">aspnetcore</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/csharp/" rel="tag">csharp</a><span class="tag-list-count">19</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dapper/" rel="tag">dapper</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dotnet/" rel="tag">dotnet</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dotnetcore/" rel="tag">dotnetcore</a><span class="tag-list-count">21</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/efcore/" rel="tag">efcore</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hangfire/" rel="tag">hangfire</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linq/" rel="tag">linq</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/patterns/" rel="tag">patterns</a><span class="tag-list-count">6</span></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">Tag Cloud</h3><div class="widget tagcloud"><a href="/tags/aspnetcore/" style="font-size:15px">aspnetcore</a> <a href="/tags/csharp/" style="font-size:18.33px">csharp</a> <a href="/tags/dapper/" style="font-size:10px">dapper</a> <a href="/tags/dotnet/" style="font-size:16.67px">dotnet</a> <a href="/tags/dotnetcore/" style="font-size:20px">dotnetcore</a> <a href="/tags/efcore/" style="font-size:11.67px">efcore</a> <a href="/tags/hangfire/" style="font-size:10px">hangfire</a> <a href="/tags/linq/" style="font-size:11.67px">linq</a> <a href="/tags/patterns/" style="font-size:13.33px">patterns</a></div></div><div class="widget-wrap"><h3 class="widget-title">Archives</h3><div class="widget"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">February 2024</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a><span class="archive-list-count">1</span></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">Recent Posts</h3><div class="widget"><ul><li><a href="/2024/06/19/NET-9-ToList-vs-ToArray/">.NET 9 - ToList vs ToArray</a></li><li><a href="/2024/05/25/NET-IAsyncEnumerable-utility-extensions/">.NET - IAsyncEnumerable utility extensions</a></li><li><a href="/2024/04/14/NET-9-%E2%80%94-Exception-handling-performance/">.NET 9 — Exception handling performance</a></li><li><a href="/2024/02/29/NET-Hangfire/">.NET - Hangfire</a></li><li><a href="/2024/02/05/NET-%E2%80%94-LinkedList-vs-ToArray/">.NET — LinkedList vs ToArray</a></li></ul></div></div></aside></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner"><a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png"></a><br>All website licensed under <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a><br>&copy; 2024 João Simões<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></div></div></footer></div><nav id="mobile-nav"><a href="/" class="mobile-nav-link">Home</a> <a href="/archives" class="mobile-nav-link">Archives</a></nav><script src="/js/jquery-3.6.4.min.js"></script><script src="/fancybox/jquery.fancybox.min.js"></script><script src="/js/script.js"></script></div></body></html>